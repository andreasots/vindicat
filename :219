{-# LANGUAGE TemplateHaskell, OverloadedStrings #-}
module Vindicat (
    PubKey(..)
  , DeviceProperty(..)
  , Signature(..)
  , Device(..)
  , LinkProperty(..)
  , Link(..)
  , mkDevice
  , deviceKeys
--  , acceptLink
  , naclSign
  , verify
) where

import Data.DeriveTH

import Data.List (find,intersect)
import Data.Maybe
import Data.Serialize
import Data.Word
import Data.ByteString.Char8 (ByteString)
import qualified Data.ByteString.Char8 as B
import Control.Monad
import Control.Applicative

import qualified  Crypto.NaCl.Key              as NaCl
import qualified Crypto.NaCl.Sign              as NaCl
import qualified Crypto.NaCl.Encrypt.PublicKey as NaCl

import Data.Time.TAI64
import SafeSerialize

instance Serialize NaCl.PublicKey where
  put = putByteString . NaCl.unPublicKey
  get = NaCl.PublicKey <$> getBytes 32 -- TODO: make NaCl typesafe :P

data PubKey = NaClKey {unNaClKey :: NaCl.PublicKey}
    deriving (Show, Eq, Ord)
$(  derive makeSerialize ''PubKey )
$(  derive makeIs        ''PubKey )

{- {{{{{{{{{{{{{{{{{{{{{{{{{{{{{ Verifications }}}}}}}}}}}}}}}}}}}}}}}}}}}}} -}

data Signature = NaClSignature {unNaClSignature :: ByteString} -- sign' -> 64byte
    deriving (Eq, Ord, Show)
$(  derive makeSerialize ''Signature )
$(  derive makeIs        ''Signature )

verify :: ByteString -> PubKey -> Signature -> Bool
verify msg (NaClKey pk) (NaClSignature sig)
 = NaCl.verify pk (sig `B.append` msg) == Just msg
verify _ _ _ = False

naclSign :: NaCl.SecretKey -> ByteString -> Signature
naclSign sk xs = NaClSignature $ NaCl.sign' sk xs
-- TODO: verify: signature is in first 64 bytes, so we can dropm the following copy of the message


{- {{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{ Device }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}} -}

data DeviceProperty = Nick {unNick :: ByteString}
                    | DeviceTime {unDeviceTime :: TAI64}
    deriving (Show, Eq, Ord)
$(  derive makeSerialize ''DeviceProperty )
$(  derive makeIs        ''DeviceProperty )

data Device = Device
  { deviceFirstKey :: Maybe PubKey
  , deviceNaClKey  :: Maybe NaCl.PublicKey
  , deviceNick     :: Maybe ByteString
  , deviceToBS     :: ByteString
  -- local fields (not serialised)
  , deviceGraphId  :: Maybe Int
  } deriving (Show, Ord,Eq)
device = Device Nothing Nothing Nothing "" Nothing

deviceKeys :: Device -> [PubKey]
deviceKeys dev = catMaybes [NaClKey <$> deviceNaClKey dev]

-- | Test whether two @Device@s represent the same physical device. Checks
-- whether a key (the intersection) has signed two devices as its own.
sameDev :: Device -> Device -> Bool
a `sameDev` b = not . null $ deviceKeys a `intersect` deviceKeys b

mkDevice :: NaCl.KeyPair -> ByteString -> Device
mkDevice (pk,sk) nick
 = device { deviceFirstKey = Just . NaClKey $ pk
          , deviceNaClKey  = Just pk
          , deviceNick     = Just nick
          , deviceToBS     = rawdevice
          } where
  rawdevice =  runPut $ do
    putByteString deviceinfo
    putNetListOf put [naclSign sk deviceinfo] -- sigs
  deviceinfo = runPut $ do
    putWord8 1 >> putWithLength put (NaClKey pk)
    putWord8 1 >> putWithLength put (Nick nick)


{-
-- | Device in wire format. Specification as Haskell code. All lists are to be
-- serialised with putNetList and getNetList
data NetDevice = NetDevice 
  { netDevPubkeys :: [PubKey]
  , netDevProps   :: [DeviceProperty]
  , netDevSig     :: [Signature]
  }
-}

instance Serialize Device where
  put = putByteString . deviceToBS
  get = do
    totalbytes <- remaining
    rawdevice  <- lookAhead $ getBytes totalbytes -- original signed Device
    keys    <- getNetListOf get
    props   <- getNetListOf get
    sigsbytes  <- remaining -- end of device info, start of verification info
    sigs    <- getNetListOf get
    let deviceinfo = B.take (totalbytes - sigsbytes) rawdevice -- shva :P
    -- the keys for which a valid signature on this device was found
    let okKeys = map fst . filter (uncurry $ verify deviceinfo) $ zip keys sigs
    -- for each field take first item of the right type
    let mb_firstkey = if (listToMaybe keys) == (listToMaybe okKeys)
                        then listToMaybe keys
                        else Nothing
    let mb_nacl_PublicKey = unNaClKey <$> find isNaClKey okKeys
    let mb_nick           = unNick    <$> find isNick    props
    return device { deviceFirstKey = mb_firstkey
                  , deviceNaClKey  = mb_nacl_PublicKey
                  , deviceNick     = mb_nick
                  , deviceToBS     = rawdevice
                  }
    
{- {{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{ Link }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}} -}

data Medium = Wifi | Cable | Optical | Pigeon
    deriving (Eq, Ord, Show)
$(  derive makeSerialize ''Medium )
$(  derive makeIs        ''Medium )

data LinkProperty = DeadLink
                  | LinkTime   {unLinkTime   :: TAI64}
                  | LinkIfaceL {unLinkIfaceL :: Word8}
                  | LinkIfaceR {unLinkIfaceR :: Word8}
                  | LinkMedium {unLinkMedium :: Medium}
    deriving (Eq, Ord, Show)
$(  derive makeSerialize ''LinkProperty )
$(  derive makeIs        ''LinkProperty )

data Link = Link -- TODO: add efficency measures
  { linkToBS     :: ByteString
  , linkLeftEnd  :: Device
  , linkRightEnd :: Device
  , linkIsRequest:: Bool
  , linkIsKnown  :: Bool
  , linkDead     :: Bool
  , linkTime     :: Maybe TAI64
  , linkMedium   :: Maybe Medium
  , linkIfaceL   :: Maybe Word8
  , linkIfaceR   :: Maybe Word8
  } deriving (Eq, Ord, Show)
link = Link "LlL" device device True False True Nothing Nothing Nothing Nothing

-- | Test whether two @Link@s represent the same physical link. Checks
-- whether there are no conflicting properties (connection type, interface)
-- but ignores differences in efficency measures and timestamps.
sameLink :: Link -> Link -> Bool
a `sameLink` b = idents a == idents b where
  idents x = (linkLeftEnd x, linkRightEnd x, linkMedium x, 
              linkIfaceL x, linkIfaceR x)

addLinkProperty :: LinkProperty -> Link -> Link
addLinkProperty p l = case p of
  DeadLink     -> l {linkDead   = True}
  LinkTime   x -> l {linkTime   = Just x}
  LinkIfaceL x -> l {linkIfaceL = Just x}
  LinkIfaceR x -> l {linkIfaceR = Just x}
  LinkMedium x -> l {linkMedium = Just x}


{-
-- | Link in wire format. Specification as Haskell code. All lists are to be
-- serialised with *NetList, signatures using *WithLength
newtype NetLink = NetLink 
   { netLinkLeftDev  :: Device 
   , netLinkRightDev :: Device 
   , netLinkProps    :: [LinkProperty]
   , netLinkLeftSig  :: Signature -- with first devices first key
   -- OPTIONAL FIELDS:
   , netLinkRightSig  :: Possibly Signature
   }
-}

instance Serialize Link where
  put = putByteString . linkToBS
  get = do
    totalbytes <- remaining
    rawlink <- lookAhead $ getBytes totalbytes
    (left,right) <- getTwoOf get get :: Get (Device, Device)
    n_props <- lookAhead $ getWord8
    props <- getNetListOf get :: Get [LinkProperty]
    -- end of device info, start of verification info
    sigsbytes <- remaining
    mb_leftSig <- getWithLength get
    secondsig <- not <$> isEmpty
    mb_rightSig <- if secondsig then getWithLength get else return Nothing
    -- Information that should be signed by both ends
    let linkinfo = B.take (totalbytes - sigsbytes) rawlink
    -- Did we understand all the properties? Won't sign ath otherwise.
    let isknown = length props == fromIntegral n_props
    -- Is this a link request?
    let isrq = not . isJust $ mb_rightSig
    let ret = link { linkToBS      = rawlink
                   , linkLeftEnd   = left
                   , linkRightEnd  = right
                   , linkIsRequest = isrq
                   , linkIsKnown   = isknown
                   } `add_p` (reverse props)
    let check dev mb_sig = False `fromMaybe` do
      key <- deviceFirstKey dev
      sig  <- mb_sig
      return $ verify linkinfo key sig
    return ret
    where add_p = foldr addLinkProperty
-}
