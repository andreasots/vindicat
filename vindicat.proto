// vim: set ts=4 sw=4 :

option optimize_for = LITE_RUNTIME;

enum HashAlgo {
	IDENTITY_HASH = 1;
	SHA256 = 2;
}

enum SigAlgo {
	BELIEVEME = 1;
	ED25519 = 2; // https://github.com/floodyberry/ed25519-donna
}

enum PkencAlgo {
	IDENTITY_ENC = 1;
	CURVE25519XSALSA20POLY1305 = 2; // http://nacl.cr.yp.to/box.html
}

message SigKey { // Signature verification key
	required SigAlgo algo = 1;
	required bytes key = 2;
}

message EncKey { // Encryption key for public-key encryption
	required PkencAlgo algo = 1;
	required bytes key = 2;
	// optional bytes nonce; // from packet header for rrq
}

message Signature {
	required SigAlgo algo = 1;
	required bytes sig = 2;
}

message EncEnvelope {
	required PkencAlgo algo = 1;
	required bytes ciphertext = 2;
	optional bytes nonce = 3;
	optional bytes enckey = 4;
}

// XXX: OBSOLETE! use raw hash prefix instead
// used where public key is available but id may not me, i.e. links
// message DeviceId { // prefix of a hash of a signing key of a device
//	required bytes prefix = 3; // the prefix of...
//	required HashAlgo HashAlgo = 1;// the $HashAlgo value of...
//	required SigAlgo SigAlgo = 2;  // a $SigAlgo key of that device
//}

// Types used in link-state updates.

message DeviceInfo {
	repeated SigKey sig_keys = 1;
	repeated EncKey enc_keys = 2;
	optional int64 time = 3; // unix "epoch" format
}


message LinkInfo {
	enum Status {
		DEAD = 1; // all other states are useable in some way
		PUBLIC = 2;
	}
	required Status status = 1;
	required bytes left = 2;  // device id
	required bytes right = 3; // device id
	optional int64 time = 4; // unix "epoch" format
	enum Transport {
		UDP = 1;
	}
	optional Transport transport = 5;
	// TODO: repeated advertisments :P
}

// Signed variants

message DeviceBusinesscard {
	required bytes device_info_msg = 1;
	repeated Signature sigs = 2;
}

message LinkPromise {
	required bytes link_info_msg = 1;
	repeated Signature left_sigs = 2;
	repeated Signature right_sigs = 3;
	// repeated Signature voucher_sigs;
}

message LinkProposal {
	required bytes link_info_msg = 1;
	repeated Signature left_sigs = 2;
	// optional DeviceBusinesscard device;
}

message Subgraph { // set of nodes and edges, right...
	repeated DeviceBusinesscard devices = 1;
	repeated LinkPromise links = 2;
}

message RoutingRequest { // follows manual headers
	optional EncKey sender_pubkey = 1; // temporary and meaningless, used for pubkey enc
	required EncEnvelope tail = 2; // Hop
}

message Hop {
	enum Type {
		SIMPLE_ONEWAY = 1; // forward all future packets and $tail to $next_hop
		SIMPLE_TWOWAY = 1; // forward all future packets and $tail to $next_hop, and all packets from him with same id pack to me
	}
	required Type type = 1;
	required bytes next = 2; // device id
	optional EncEnvelope tail = 3; // Hop
}

// implemented manually
// message VindicatPacket {
//	// 0 is for routed packets with fixed headers
//	// 1 is for routing requests: fixed headers + RoutingDetails
//	optional Subgraph lsr_update = 2;
//	optional LinkProposal link_proposal = 3;
//	optional DeviceBusinesscard beacon = 4;
// }
