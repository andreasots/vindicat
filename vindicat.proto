// vim: set ts=4 sw=4 :
option optimize_for = LITE_RUNTIME;

// Algorithm specifiers
enum HashAlgo {
	IDENTITY_HASH = 1;
	SHA256 = 2;
}

enum SigAlgo {
	BELIEVEME = 1;
	ED25519 = 2; // https://github.com/floodyberry/ed25519-donna
}

enum PkencAlgo {
	IDENTITY_ENC = 1;
	CURVE25519XSALSA20POLY1305 = 2; // http://nacl.cr.yp.to/box.html
}


// Keys
message SigKey { // Signature verification key
	required SigAlgo algo = 1;
	required bytes key = 2;
}

message EncKey { // Encryption key for public-key encryption
	required PkencAlgo algo = 1;
	required bytes key = 2;
	// optional bytes nonce; // from packet header for rrq
}


// Cryptographic containers
message Signature {
	required SigAlgo algo = 1;
	required bytes sig = 2;
}

message EncEnvelope {
	required PkencAlgo algo = 1;
	required bytes ciphertext = 2;
	optional bytes nonce = 3;
	optional bytes enckey = 4;
}


// Actual serialization
message DeviceInfo {
	repeated SigKey sig_keys = 1;
	repeated EncKey enc_keys = 2;
	optional int64 time = 3; // unix "epoch" format
	repeated bytes identifiers = 999; // list of (device id), not included on the wire
}

message LinkInfo {
	enum Status {
		DEAD = 1; // all other states are useable in some way
		PUBLIC = 2;
	}
	required Status status = 1;
	required bytes left = 2;  // device id
	required bytes right = 3; // device id
	optional int64 time = 4; // unix "epoch" format
	// enum Transport {
	// 	UDP = 1;
	// }
	// optional Transport transport = 5;
	// TODO: repeated advertisments :P
}


// Complicated signed variants of serialised structures
message DeviceBusinesscard {
	required bytes device_info_msg = 1; // DeviceInfo
	repeated Signature sigs = 2;
}

message LinkPromise {
	required bytes link_info_msg = 1; // LinkInfo
	repeated Signature left_sigs = 2;
	repeated Signature right_sigs = 3;
	// repeated Signature voucher_sigs;
}

message LinkProposal {
	required bytes link_info_msg = 1; // LinkInfo
	repeated Signature left_sigs = 2;
	// optional DeviceBusinesscard device;
}


// Compound messages

message Subgraph { // set of nodes and edges, right...
	repeated DeviceBusinesscard devices = 1;
	repeated LinkPromise links = 2;
}

message Hop {
	enum Type {
		UP = 1;
		SIMPLE_ONEWAY = 2; // forward all future packets and $tail to $next_hop
		SIMPLE_TWOWAY = 3; // forward all future packets and $tail to $next_hop, and all packets from him with same id pack to me
	}
	required Type type = 1;
	optional bytes next = 2; // device id
	optional EncEnvelope tail = 3; // Hop
}

message RoutingRequest { // follows manual headers
	optional EncKey sender_pubkey = 1; // temporary and meaningless, used for pubkey enc
	required EncEnvelope tail = 2; // Hop
}


// implemented manually
// message VindicatPacket {
//	// 0 is for routed packets with fixed headers
//	// 1 is for routing requests: fixed headers + RoutingDetails
//	optional Subgraph lsr_update = 2;
//	optional LinkProposal link_proposal = 3;
//	optional DeviceBusinesscard beacon = 4;
// }
