// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vindicat.proto

#ifndef PROTOBUF_vindicat_2eproto__INCLUDED
#define PROTOBUF_vindicat_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_vindicat_2eproto();
void protobuf_AssignDesc_vindicat_2eproto();
void protobuf_ShutdownFile_vindicat_2eproto();

class DeviceInfo;
class DeviceBusinesscard;
class LinkInfo;
class LinkProposal;
class LinkPromise;
class Subgraph;
class RoutingRequest;
class Hop;
class ConnectionAccept;

enum LinkInfo_Status {
  LinkInfo_Status_DEAD = 1,
  LinkInfo_Status_PUBLIC = 2
};
bool LinkInfo_Status_IsValid(int value);
const LinkInfo_Status LinkInfo_Status_Status_MIN = LinkInfo_Status_DEAD;
const LinkInfo_Status LinkInfo_Status_Status_MAX = LinkInfo_Status_PUBLIC;
const int LinkInfo_Status_Status_ARRAYSIZE = LinkInfo_Status_Status_MAX + 1;

enum Hop_Type {
  Hop_Type_UP = 1,
  Hop_Type_SIMPLE_ONEWAY = 2,
  Hop_Type_SIMPLE_TWOWAY = 3
};
bool Hop_Type_IsValid(int value);
const Hop_Type Hop_Type_Type_MIN = Hop_Type_UP;
const Hop_Type Hop_Type_Type_MAX = Hop_Type_SIMPLE_TWOWAY;
const int Hop_Type_Type_ARRAYSIZE = Hop_Type_Type_MAX + 1;

enum Hop_NonceAlgo {
  Hop_NonceAlgo_XTEA32 = 2
};
bool Hop_NonceAlgo_IsValid(int value);
const Hop_NonceAlgo Hop_NonceAlgo_NonceAlgo_MIN = Hop_NonceAlgo_XTEA32;
const Hop_NonceAlgo Hop_NonceAlgo_NonceAlgo_MAX = Hop_NonceAlgo_XTEA32;
const int Hop_NonceAlgo_NonceAlgo_ARRAYSIZE = Hop_NonceAlgo_NonceAlgo_MAX + 1;

enum ConnectionAccept_Auth {
  ConnectionAccept_Auth_AUTHENC_BCARD = 1
};
bool ConnectionAccept_Auth_IsValid(int value);
const ConnectionAccept_Auth ConnectionAccept_Auth_Auth_MIN = ConnectionAccept_Auth_AUTHENC_BCARD;
const ConnectionAccept_Auth ConnectionAccept_Auth_Auth_MAX = ConnectionAccept_Auth_AUTHENC_BCARD;
const int ConnectionAccept_Auth_Auth_ARRAYSIZE = ConnectionAccept_Auth_Auth_MAX + 1;

// ===================================================================

class DeviceInfo : public ::google::protobuf::MessageLite {
 public:
  DeviceInfo();
  virtual ~DeviceInfo();

  DeviceInfo(const DeviceInfo& from);

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const DeviceInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeviceInfo* other);

  // implements Message ----------------------------------------------

  DeviceInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceInfo& from);
  void MergeFrom(const DeviceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 sig_algos = 1;
  inline int sig_algos_size() const;
  inline void clear_sig_algos();
  static const int kSigAlgosFieldNumber = 1;
  inline ::google::protobuf::uint32 sig_algos(int index) const;
  inline void set_sig_algos(int index, ::google::protobuf::uint32 value);
  inline void add_sig_algos(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      sig_algos() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_sig_algos();

  // repeated uint32 enc_algos = 2;
  inline int enc_algos_size() const;
  inline void clear_enc_algos();
  static const int kEncAlgosFieldNumber = 2;
  inline ::google::protobuf::uint32 enc_algos(int index) const;
  inline void set_enc_algos(int index, ::google::protobuf::uint32 value);
  inline void add_enc_algos(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      enc_algos() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_enc_algos();

  // repeated bytes sig_keys = 3;
  inline int sig_keys_size() const;
  inline void clear_sig_keys();
  static const int kSigKeysFieldNumber = 3;
  inline const ::std::string& sig_keys(int index) const;
  inline ::std::string* mutable_sig_keys(int index);
  inline void set_sig_keys(int index, const ::std::string& value);
  inline void set_sig_keys(int index, const char* value);
  inline void set_sig_keys(int index, const void* value, size_t size);
  inline ::std::string* add_sig_keys();
  inline void add_sig_keys(const ::std::string& value);
  inline void add_sig_keys(const char* value);
  inline void add_sig_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& sig_keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sig_keys();

  // repeated bytes enc_keys = 4;
  inline int enc_keys_size() const;
  inline void clear_enc_keys();
  static const int kEncKeysFieldNumber = 4;
  inline const ::std::string& enc_keys(int index) const;
  inline ::std::string* mutable_enc_keys(int index);
  inline void set_enc_keys(int index, const ::std::string& value);
  inline void set_enc_keys(int index, const char* value);
  inline void set_enc_keys(int index, const void* value, size_t size);
  inline ::std::string* add_enc_keys();
  inline void add_enc_keys(const ::std::string& value);
  inline void add_enc_keys(const char* value);
  inline void add_enc_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& enc_keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_enc_keys();

  // optional int64 time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:DeviceInfo)
 private:
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > sig_algos_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > enc_algos_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sig_keys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> enc_keys_;
  ::google::protobuf::int64 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vindicat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vindicat_2eproto();
  #endif
  friend void protobuf_AssignDesc_vindicat_2eproto();
  friend void protobuf_ShutdownFile_vindicat_2eproto();

  void InitAsDefaultInstance();
  static DeviceInfo* default_instance_;
};
// -------------------------------------------------------------------

class DeviceBusinesscard : public ::google::protobuf::MessageLite {
 public:
  DeviceBusinesscard();
  virtual ~DeviceBusinesscard();

  DeviceBusinesscard(const DeviceBusinesscard& from);

  inline DeviceBusinesscard& operator=(const DeviceBusinesscard& from) {
    CopyFrom(from);
    return *this;
  }

  static const DeviceBusinesscard& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceBusinesscard* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeviceBusinesscard* other);

  // implements Message ----------------------------------------------

  DeviceBusinesscard* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceBusinesscard& from);
  void MergeFrom(const DeviceBusinesscard& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes device_info_msg = 1;
  inline bool has_device_info_msg() const;
  inline void clear_device_info_msg();
  static const int kDeviceInfoMsgFieldNumber = 1;
  inline const ::std::string& device_info_msg() const;
  inline void set_device_info_msg(const ::std::string& value);
  inline void set_device_info_msg(const char* value);
  inline void set_device_info_msg(const void* value, size_t size);
  inline ::std::string* mutable_device_info_msg();
  inline ::std::string* release_device_info_msg();
  inline void set_allocated_device_info_msg(::std::string* device_info_msg);

  // repeated bytes sigs = 2;
  inline int sigs_size() const;
  inline void clear_sigs();
  static const int kSigsFieldNumber = 2;
  inline const ::std::string& sigs(int index) const;
  inline ::std::string* mutable_sigs(int index);
  inline void set_sigs(int index, const ::std::string& value);
  inline void set_sigs(int index, const char* value);
  inline void set_sigs(int index, const void* value, size_t size);
  inline ::std::string* add_sigs();
  inline void add_sigs(const ::std::string& value);
  inline void add_sigs(const char* value);
  inline void add_sigs(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& sigs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sigs();

  // @@protoc_insertion_point(class_scope:DeviceBusinesscard)
 private:
  inline void set_has_device_info_msg();
  inline void clear_has_device_info_msg();

  ::std::string* device_info_msg_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sigs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vindicat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vindicat_2eproto();
  #endif
  friend void protobuf_AssignDesc_vindicat_2eproto();
  friend void protobuf_ShutdownFile_vindicat_2eproto();

  void InitAsDefaultInstance();
  static DeviceBusinesscard* default_instance_;
};
// -------------------------------------------------------------------

class LinkInfo : public ::google::protobuf::MessageLite {
 public:
  LinkInfo();
  virtual ~LinkInfo();

  LinkInfo(const LinkInfo& from);

  inline LinkInfo& operator=(const LinkInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const LinkInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LinkInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LinkInfo* other);

  // implements Message ----------------------------------------------

  LinkInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LinkInfo& from);
  void MergeFrom(const LinkInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LinkInfo_Status Status;
  static const Status DEAD = LinkInfo_Status_DEAD;
  static const Status PUBLIC = LinkInfo_Status_PUBLIC;
  static inline bool Status_IsValid(int value) {
    return LinkInfo_Status_IsValid(value);
  }
  static const Status Status_MIN =
    LinkInfo_Status_Status_MIN;
  static const Status Status_MAX =
    LinkInfo_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    LinkInfo_Status_Status_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .LinkInfo.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::LinkInfo_Status status() const;
  inline void set_status(::LinkInfo_Status value);

  // required bytes left = 2;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 2;
  inline const ::std::string& left() const;
  inline void set_left(const ::std::string& value);
  inline void set_left(const char* value);
  inline void set_left(const void* value, size_t size);
  inline ::std::string* mutable_left();
  inline ::std::string* release_left();
  inline void set_allocated_left(::std::string* left);

  // required bytes right = 3;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 3;
  inline const ::std::string& right() const;
  inline void set_right(const ::std::string& value);
  inline void set_right(const char* value);
  inline void set_right(const void* value, size_t size);
  inline ::std::string* mutable_right();
  inline ::std::string* release_right();
  inline void set_allocated_right(::std::string* right);

  // optional int64 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:LinkInfo)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_time();
  inline void clear_has_time();

  ::std::string* left_;
  ::std::string* right_;
  ::google::protobuf::int64 time_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vindicat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vindicat_2eproto();
  #endif
  friend void protobuf_AssignDesc_vindicat_2eproto();
  friend void protobuf_ShutdownFile_vindicat_2eproto();

  void InitAsDefaultInstance();
  static LinkInfo* default_instance_;
};
// -------------------------------------------------------------------

class LinkProposal : public ::google::protobuf::MessageLite {
 public:
  LinkProposal();
  virtual ~LinkProposal();

  LinkProposal(const LinkProposal& from);

  inline LinkProposal& operator=(const LinkProposal& from) {
    CopyFrom(from);
    return *this;
  }

  static const LinkProposal& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LinkProposal* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LinkProposal* other);

  // implements Message ----------------------------------------------

  LinkProposal* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LinkProposal& from);
  void MergeFrom(const LinkProposal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 left_sig_algos = 1;
  inline int left_sig_algos_size() const;
  inline void clear_left_sig_algos();
  static const int kLeftSigAlgosFieldNumber = 1;
  inline ::google::protobuf::uint32 left_sig_algos(int index) const;
  inline void set_left_sig_algos(int index, ::google::protobuf::uint32 value);
  inline void add_left_sig_algos(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      left_sig_algos() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_left_sig_algos();

  // required bytes link_info_msg = 3;
  inline bool has_link_info_msg() const;
  inline void clear_link_info_msg();
  static const int kLinkInfoMsgFieldNumber = 3;
  inline const ::std::string& link_info_msg() const;
  inline void set_link_info_msg(const ::std::string& value);
  inline void set_link_info_msg(const char* value);
  inline void set_link_info_msg(const void* value, size_t size);
  inline ::std::string* mutable_link_info_msg();
  inline ::std::string* release_link_info_msg();
  inline void set_allocated_link_info_msg(::std::string* link_info_msg);

  // repeated bytes left_sigs = 4;
  inline int left_sigs_size() const;
  inline void clear_left_sigs();
  static const int kLeftSigsFieldNumber = 4;
  inline const ::std::string& left_sigs(int index) const;
  inline ::std::string* mutable_left_sigs(int index);
  inline void set_left_sigs(int index, const ::std::string& value);
  inline void set_left_sigs(int index, const char* value);
  inline void set_left_sigs(int index, const void* value, size_t size);
  inline ::std::string* add_left_sigs();
  inline void add_left_sigs(const ::std::string& value);
  inline void add_left_sigs(const char* value);
  inline void add_left_sigs(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& left_sigs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_left_sigs();

  // @@protoc_insertion_point(class_scope:LinkProposal)
 private:
  inline void set_has_link_info_msg();
  inline void clear_has_link_info_msg();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > left_sig_algos_;
  ::std::string* link_info_msg_;
  ::google::protobuf::RepeatedPtrField< ::std::string> left_sigs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vindicat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vindicat_2eproto();
  #endif
  friend void protobuf_AssignDesc_vindicat_2eproto();
  friend void protobuf_ShutdownFile_vindicat_2eproto();

  void InitAsDefaultInstance();
  static LinkProposal* default_instance_;
};
// -------------------------------------------------------------------

class LinkPromise : public ::google::protobuf::MessageLite {
 public:
  LinkPromise();
  virtual ~LinkPromise();

  LinkPromise(const LinkPromise& from);

  inline LinkPromise& operator=(const LinkPromise& from) {
    CopyFrom(from);
    return *this;
  }

  static const LinkPromise& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LinkPromise* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LinkPromise* other);

  // implements Message ----------------------------------------------

  LinkPromise* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LinkPromise& from);
  void MergeFrom(const LinkPromise& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 left_sig_algos = 1;
  inline int left_sig_algos_size() const;
  inline void clear_left_sig_algos();
  static const int kLeftSigAlgosFieldNumber = 1;
  inline ::google::protobuf::uint32 left_sig_algos(int index) const;
  inline void set_left_sig_algos(int index, ::google::protobuf::uint32 value);
  inline void add_left_sig_algos(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      left_sig_algos() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_left_sig_algos();

  // repeated uint32 right_sig_algos = 2;
  inline int right_sig_algos_size() const;
  inline void clear_right_sig_algos();
  static const int kRightSigAlgosFieldNumber = 2;
  inline ::google::protobuf::uint32 right_sig_algos(int index) const;
  inline void set_right_sig_algos(int index, ::google::protobuf::uint32 value);
  inline void add_right_sig_algos(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      right_sig_algos() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_right_sig_algos();

  // required bytes link_info_msg = 3;
  inline bool has_link_info_msg() const;
  inline void clear_link_info_msg();
  static const int kLinkInfoMsgFieldNumber = 3;
  inline const ::std::string& link_info_msg() const;
  inline void set_link_info_msg(const ::std::string& value);
  inline void set_link_info_msg(const char* value);
  inline void set_link_info_msg(const void* value, size_t size);
  inline ::std::string* mutable_link_info_msg();
  inline ::std::string* release_link_info_msg();
  inline void set_allocated_link_info_msg(::std::string* link_info_msg);

  // repeated bytes left_sigs = 4;
  inline int left_sigs_size() const;
  inline void clear_left_sigs();
  static const int kLeftSigsFieldNumber = 4;
  inline const ::std::string& left_sigs(int index) const;
  inline ::std::string* mutable_left_sigs(int index);
  inline void set_left_sigs(int index, const ::std::string& value);
  inline void set_left_sigs(int index, const char* value);
  inline void set_left_sigs(int index, const void* value, size_t size);
  inline ::std::string* add_left_sigs();
  inline void add_left_sigs(const ::std::string& value);
  inline void add_left_sigs(const char* value);
  inline void add_left_sigs(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& left_sigs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_left_sigs();

  // repeated bytes right_sigs = 5;
  inline int right_sigs_size() const;
  inline void clear_right_sigs();
  static const int kRightSigsFieldNumber = 5;
  inline const ::std::string& right_sigs(int index) const;
  inline ::std::string* mutable_right_sigs(int index);
  inline void set_right_sigs(int index, const ::std::string& value);
  inline void set_right_sigs(int index, const char* value);
  inline void set_right_sigs(int index, const void* value, size_t size);
  inline ::std::string* add_right_sigs();
  inline void add_right_sigs(const ::std::string& value);
  inline void add_right_sigs(const char* value);
  inline void add_right_sigs(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& right_sigs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_right_sigs();

  // @@protoc_insertion_point(class_scope:LinkPromise)
 private:
  inline void set_has_link_info_msg();
  inline void clear_has_link_info_msg();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > left_sig_algos_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > right_sig_algos_;
  ::std::string* link_info_msg_;
  ::google::protobuf::RepeatedPtrField< ::std::string> left_sigs_;
  ::google::protobuf::RepeatedPtrField< ::std::string> right_sigs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vindicat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vindicat_2eproto();
  #endif
  friend void protobuf_AssignDesc_vindicat_2eproto();
  friend void protobuf_ShutdownFile_vindicat_2eproto();

  void InitAsDefaultInstance();
  static LinkPromise* default_instance_;
};
// -------------------------------------------------------------------

class Subgraph : public ::google::protobuf::MessageLite {
 public:
  Subgraph();
  virtual ~Subgraph();

  Subgraph(const Subgraph& from);

  inline Subgraph& operator=(const Subgraph& from) {
    CopyFrom(from);
    return *this;
  }

  static const Subgraph& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Subgraph* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Subgraph* other);

  // implements Message ----------------------------------------------

  Subgraph* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Subgraph& from);
  void MergeFrom(const Subgraph& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DeviceBusinesscard devices = 1;
  inline int devices_size() const;
  inline void clear_devices();
  static const int kDevicesFieldNumber = 1;
  inline const ::DeviceBusinesscard& devices(int index) const;
  inline ::DeviceBusinesscard* mutable_devices(int index);
  inline ::DeviceBusinesscard* add_devices();
  inline const ::google::protobuf::RepeatedPtrField< ::DeviceBusinesscard >&
      devices() const;
  inline ::google::protobuf::RepeatedPtrField< ::DeviceBusinesscard >*
      mutable_devices();

  // repeated .LinkPromise links = 2;
  inline int links_size() const;
  inline void clear_links();
  static const int kLinksFieldNumber = 2;
  inline const ::LinkPromise& links(int index) const;
  inline ::LinkPromise* mutable_links(int index);
  inline ::LinkPromise* add_links();
  inline const ::google::protobuf::RepeatedPtrField< ::LinkPromise >&
      links() const;
  inline ::google::protobuf::RepeatedPtrField< ::LinkPromise >*
      mutable_links();

  // @@protoc_insertion_point(class_scope:Subgraph)
 private:

  ::google::protobuf::RepeatedPtrField< ::DeviceBusinesscard > devices_;
  ::google::protobuf::RepeatedPtrField< ::LinkPromise > links_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vindicat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vindicat_2eproto();
  #endif
  friend void protobuf_AssignDesc_vindicat_2eproto();
  friend void protobuf_ShutdownFile_vindicat_2eproto();

  void InitAsDefaultInstance();
  static Subgraph* default_instance_;
};
// -------------------------------------------------------------------

class RoutingRequest : public ::google::protobuf::MessageLite {
 public:
  RoutingRequest();
  virtual ~RoutingRequest();

  RoutingRequest(const RoutingRequest& from);

  inline RoutingRequest& operator=(const RoutingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const RoutingRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RoutingRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RoutingRequest* other);

  // implements Message ----------------------------------------------

  RoutingRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RoutingRequest& from);
  void MergeFrom(const RoutingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 enc_algo = 1;
  inline bool has_enc_algo() const;
  inline void clear_enc_algo();
  static const int kEncAlgoFieldNumber = 1;
  inline ::google::protobuf::uint32 enc_algo() const;
  inline void set_enc_algo(::google::protobuf::uint32 value);

  // optional bytes sender_pubkey = 2;
  inline bool has_sender_pubkey() const;
  inline void clear_sender_pubkey();
  static const int kSenderPubkeyFieldNumber = 2;
  inline const ::std::string& sender_pubkey() const;
  inline void set_sender_pubkey(const ::std::string& value);
  inline void set_sender_pubkey(const char* value);
  inline void set_sender_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_sender_pubkey();
  inline ::std::string* release_sender_pubkey();
  inline void set_allocated_sender_pubkey(::std::string* sender_pubkey);

  // required bytes details = 3;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 3;
  inline const ::std::string& details() const;
  inline void set_details(const ::std::string& value);
  inline void set_details(const char* value);
  inline void set_details(const void* value, size_t size);
  inline ::std::string* mutable_details();
  inline ::std::string* release_details();
  inline void set_allocated_details(::std::string* details);

  // @@protoc_insertion_point(class_scope:RoutingRequest)
 private:
  inline void set_has_enc_algo();
  inline void clear_has_enc_algo();
  inline void set_has_sender_pubkey();
  inline void clear_has_sender_pubkey();
  inline void set_has_details();
  inline void clear_has_details();

  ::std::string* sender_pubkey_;
  ::std::string* details_;
  ::google::protobuf::uint32 enc_algo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vindicat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vindicat_2eproto();
  #endif
  friend void protobuf_AssignDesc_vindicat_2eproto();
  friend void protobuf_ShutdownFile_vindicat_2eproto();

  void InitAsDefaultInstance();
  static RoutingRequest* default_instance_;
};
// -------------------------------------------------------------------

class Hop : public ::google::protobuf::MessageLite {
 public:
  Hop();
  virtual ~Hop();

  Hop(const Hop& from);

  inline Hop& operator=(const Hop& from) {
    CopyFrom(from);
    return *this;
  }

  static const Hop& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Hop* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Hop* other);

  // implements Message ----------------------------------------------

  Hop* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Hop& from);
  void MergeFrom(const Hop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Hop_Type Type;
  static const Type UP = Hop_Type_UP;
  static const Type SIMPLE_ONEWAY = Hop_Type_SIMPLE_ONEWAY;
  static const Type SIMPLE_TWOWAY = Hop_Type_SIMPLE_TWOWAY;
  static inline bool Type_IsValid(int value) {
    return Hop_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Hop_Type_Type_MIN;
  static const Type Type_MAX =
    Hop_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Hop_Type_Type_ARRAYSIZE;

  typedef Hop_NonceAlgo NonceAlgo;
  static const NonceAlgo XTEA32 = Hop_NonceAlgo_XTEA32;
  static inline bool NonceAlgo_IsValid(int value) {
    return Hop_NonceAlgo_IsValid(value);
  }
  static const NonceAlgo NonceAlgo_MIN =
    Hop_NonceAlgo_NonceAlgo_MIN;
  static const NonceAlgo NonceAlgo_MAX =
    Hop_NonceAlgo_NonceAlgo_MAX;
  static const int NonceAlgo_ARRAYSIZE =
    Hop_NonceAlgo_NonceAlgo_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .Hop.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Hop_Type type() const;
  inline void set_type(::Hop_Type value);

  // optional bytes next = 2;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 2;
  inline const ::std::string& next() const;
  inline void set_next(const ::std::string& value);
  inline void set_next(const char* value);
  inline void set_next(const void* value, size_t size);
  inline ::std::string* mutable_next();
  inline ::std::string* release_next();
  inline void set_allocated_next(::std::string* next);

  // optional uint32 enc_algo = 3;
  inline bool has_enc_algo() const;
  inline void clear_enc_algo();
  static const int kEncAlgoFieldNumber = 3;
  inline ::google::protobuf::uint32 enc_algo() const;
  inline void set_enc_algo(::google::protobuf::uint32 value);

  // optional bytes sender_pubkey = 4;
  inline bool has_sender_pubkey() const;
  inline void clear_sender_pubkey();
  static const int kSenderPubkeyFieldNumber = 4;
  inline const ::std::string& sender_pubkey() const;
  inline void set_sender_pubkey(const ::std::string& value);
  inline void set_sender_pubkey(const char* value);
  inline void set_sender_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_sender_pubkey();
  inline ::std::string* release_sender_pubkey();
  inline void set_allocated_sender_pubkey(::std::string* sender_pubkey);

  // optional bytes details = 5;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 5;
  inline const ::std::string& details() const;
  inline void set_details(const ::std::string& value);
  inline void set_details(const char* value);
  inline void set_details(const void* value, size_t size);
  inline ::std::string* mutable_details();
  inline ::std::string* release_details();
  inline void set_allocated_details(::std::string* details);

  // optional .Hop.NonceAlgo nonce_algo = 6;
  inline bool has_nonce_algo() const;
  inline void clear_nonce_algo();
  static const int kNonceAlgoFieldNumber = 6;
  inline ::Hop_NonceAlgo nonce_algo() const;
  inline void set_nonce_algo(::Hop_NonceAlgo value);

  // @@protoc_insertion_point(class_scope:Hop)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_next();
  inline void clear_has_next();
  inline void set_has_enc_algo();
  inline void clear_has_enc_algo();
  inline void set_has_sender_pubkey();
  inline void clear_has_sender_pubkey();
  inline void set_has_details();
  inline void clear_has_details();
  inline void set_has_nonce_algo();
  inline void clear_has_nonce_algo();

  ::std::string* next_;
  int type_;
  ::google::protobuf::uint32 enc_algo_;
  ::std::string* sender_pubkey_;
  ::std::string* details_;
  int nonce_algo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vindicat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vindicat_2eproto();
  #endif
  friend void protobuf_AssignDesc_vindicat_2eproto();
  friend void protobuf_ShutdownFile_vindicat_2eproto();

  void InitAsDefaultInstance();
  static Hop* default_instance_;
};
// -------------------------------------------------------------------

class ConnectionAccept : public ::google::protobuf::MessageLite {
 public:
  ConnectionAccept();
  virtual ~ConnectionAccept();

  ConnectionAccept(const ConnectionAccept& from);

  inline ConnectionAccept& operator=(const ConnectionAccept& from) {
    CopyFrom(from);
    return *this;
  }

  static const ConnectionAccept& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConnectionAccept* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConnectionAccept* other);

  // implements Message ----------------------------------------------

  ConnectionAccept* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConnectionAccept& from);
  void MergeFrom(const ConnectionAccept& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ConnectionAccept_Auth Auth;
  static const Auth AUTHENC_BCARD = ConnectionAccept_Auth_AUTHENC_BCARD;
  static inline bool Auth_IsValid(int value) {
    return ConnectionAccept_Auth_IsValid(value);
  }
  static const Auth Auth_MIN =
    ConnectionAccept_Auth_Auth_MIN;
  static const Auth Auth_MAX =
    ConnectionAccept_Auth_Auth_MAX;
  static const int Auth_ARRAYSIZE =
    ConnectionAccept_Auth_Auth_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional bytes sender_pubkey = 1;
  inline bool has_sender_pubkey() const;
  inline void clear_sender_pubkey();
  static const int kSenderPubkeyFieldNumber = 1;
  inline const ::std::string& sender_pubkey() const;
  inline void set_sender_pubkey(const ::std::string& value);
  inline void set_sender_pubkey(const char* value);
  inline void set_sender_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_sender_pubkey();
  inline ::std::string* release_sender_pubkey();
  inline void set_allocated_sender_pubkey(::std::string* sender_pubkey);

  // required .ConnectionAccept.Auth auth = 2;
  inline bool has_auth() const;
  inline void clear_auth();
  static const int kAuthFieldNumber = 2;
  inline ::ConnectionAccept_Auth auth() const;
  inline void set_auth(::ConnectionAccept_Auth value);

  // required bytes cookie = 3;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 3;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const void* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // @@protoc_insertion_point(class_scope:ConnectionAccept)
 private:
  inline void set_has_sender_pubkey();
  inline void clear_has_sender_pubkey();
  inline void set_has_auth();
  inline void clear_has_auth();
  inline void set_has_cookie();
  inline void clear_has_cookie();

  ::std::string* sender_pubkey_;
  ::std::string* cookie_;
  int auth_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vindicat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vindicat_2eproto();
  #endif
  friend void protobuf_AssignDesc_vindicat_2eproto();
  friend void protobuf_ShutdownFile_vindicat_2eproto();

  void InitAsDefaultInstance();
  static ConnectionAccept* default_instance_;
};
// ===================================================================


// ===================================================================

// DeviceInfo

// repeated uint32 sig_algos = 1;
inline int DeviceInfo::sig_algos_size() const {
  return sig_algos_.size();
}
inline void DeviceInfo::clear_sig_algos() {
  sig_algos_.Clear();
}
inline ::google::protobuf::uint32 DeviceInfo::sig_algos(int index) const {
  return sig_algos_.Get(index);
}
inline void DeviceInfo::set_sig_algos(int index, ::google::protobuf::uint32 value) {
  sig_algos_.Set(index, value);
}
inline void DeviceInfo::add_sig_algos(::google::protobuf::uint32 value) {
  sig_algos_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DeviceInfo::sig_algos() const {
  return sig_algos_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DeviceInfo::mutable_sig_algos() {
  return &sig_algos_;
}

// repeated uint32 enc_algos = 2;
inline int DeviceInfo::enc_algos_size() const {
  return enc_algos_.size();
}
inline void DeviceInfo::clear_enc_algos() {
  enc_algos_.Clear();
}
inline ::google::protobuf::uint32 DeviceInfo::enc_algos(int index) const {
  return enc_algos_.Get(index);
}
inline void DeviceInfo::set_enc_algos(int index, ::google::protobuf::uint32 value) {
  enc_algos_.Set(index, value);
}
inline void DeviceInfo::add_enc_algos(::google::protobuf::uint32 value) {
  enc_algos_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DeviceInfo::enc_algos() const {
  return enc_algos_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DeviceInfo::mutable_enc_algos() {
  return &enc_algos_;
}

// repeated bytes sig_keys = 3;
inline int DeviceInfo::sig_keys_size() const {
  return sig_keys_.size();
}
inline void DeviceInfo::clear_sig_keys() {
  sig_keys_.Clear();
}
inline const ::std::string& DeviceInfo::sig_keys(int index) const {
  return sig_keys_.Get(index);
}
inline ::std::string* DeviceInfo::mutable_sig_keys(int index) {
  return sig_keys_.Mutable(index);
}
inline void DeviceInfo::set_sig_keys(int index, const ::std::string& value) {
  sig_keys_.Mutable(index)->assign(value);
}
inline void DeviceInfo::set_sig_keys(int index, const char* value) {
  sig_keys_.Mutable(index)->assign(value);
}
inline void DeviceInfo::set_sig_keys(int index, const void* value, size_t size) {
  sig_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::add_sig_keys() {
  return sig_keys_.Add();
}
inline void DeviceInfo::add_sig_keys(const ::std::string& value) {
  sig_keys_.Add()->assign(value);
}
inline void DeviceInfo::add_sig_keys(const char* value) {
  sig_keys_.Add()->assign(value);
}
inline void DeviceInfo::add_sig_keys(const void* value, size_t size) {
  sig_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DeviceInfo::sig_keys() const {
  return sig_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DeviceInfo::mutable_sig_keys() {
  return &sig_keys_;
}

// repeated bytes enc_keys = 4;
inline int DeviceInfo::enc_keys_size() const {
  return enc_keys_.size();
}
inline void DeviceInfo::clear_enc_keys() {
  enc_keys_.Clear();
}
inline const ::std::string& DeviceInfo::enc_keys(int index) const {
  return enc_keys_.Get(index);
}
inline ::std::string* DeviceInfo::mutable_enc_keys(int index) {
  return enc_keys_.Mutable(index);
}
inline void DeviceInfo::set_enc_keys(int index, const ::std::string& value) {
  enc_keys_.Mutable(index)->assign(value);
}
inline void DeviceInfo::set_enc_keys(int index, const char* value) {
  enc_keys_.Mutable(index)->assign(value);
}
inline void DeviceInfo::set_enc_keys(int index, const void* value, size_t size) {
  enc_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::add_enc_keys() {
  return enc_keys_.Add();
}
inline void DeviceInfo::add_enc_keys(const ::std::string& value) {
  enc_keys_.Add()->assign(value);
}
inline void DeviceInfo::add_enc_keys(const char* value) {
  enc_keys_.Add()->assign(value);
}
inline void DeviceInfo::add_enc_keys(const void* value, size_t size) {
  enc_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DeviceInfo::enc_keys() const {
  return enc_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DeviceInfo::mutable_enc_keys() {
  return &enc_keys_;
}

// optional int64 time = 5;
inline bool DeviceInfo::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceInfo::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceInfo::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 DeviceInfo::time() const {
  return time_;
}
inline void DeviceInfo::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// DeviceBusinesscard

// required bytes device_info_msg = 1;
inline bool DeviceBusinesscard::has_device_info_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceBusinesscard::set_has_device_info_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceBusinesscard::clear_has_device_info_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceBusinesscard::clear_device_info_msg() {
  if (device_info_msg_ != &::google::protobuf::internal::kEmptyString) {
    device_info_msg_->clear();
  }
  clear_has_device_info_msg();
}
inline const ::std::string& DeviceBusinesscard::device_info_msg() const {
  return *device_info_msg_;
}
inline void DeviceBusinesscard::set_device_info_msg(const ::std::string& value) {
  set_has_device_info_msg();
  if (device_info_msg_ == &::google::protobuf::internal::kEmptyString) {
    device_info_msg_ = new ::std::string;
  }
  device_info_msg_->assign(value);
}
inline void DeviceBusinesscard::set_device_info_msg(const char* value) {
  set_has_device_info_msg();
  if (device_info_msg_ == &::google::protobuf::internal::kEmptyString) {
    device_info_msg_ = new ::std::string;
  }
  device_info_msg_->assign(value);
}
inline void DeviceBusinesscard::set_device_info_msg(const void* value, size_t size) {
  set_has_device_info_msg();
  if (device_info_msg_ == &::google::protobuf::internal::kEmptyString) {
    device_info_msg_ = new ::std::string;
  }
  device_info_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceBusinesscard::mutable_device_info_msg() {
  set_has_device_info_msg();
  if (device_info_msg_ == &::google::protobuf::internal::kEmptyString) {
    device_info_msg_ = new ::std::string;
  }
  return device_info_msg_;
}
inline ::std::string* DeviceBusinesscard::release_device_info_msg() {
  clear_has_device_info_msg();
  if (device_info_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_info_msg_;
    device_info_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceBusinesscard::set_allocated_device_info_msg(::std::string* device_info_msg) {
  if (device_info_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete device_info_msg_;
  }
  if (device_info_msg) {
    set_has_device_info_msg();
    device_info_msg_ = device_info_msg;
  } else {
    clear_has_device_info_msg();
    device_info_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated bytes sigs = 2;
inline int DeviceBusinesscard::sigs_size() const {
  return sigs_.size();
}
inline void DeviceBusinesscard::clear_sigs() {
  sigs_.Clear();
}
inline const ::std::string& DeviceBusinesscard::sigs(int index) const {
  return sigs_.Get(index);
}
inline ::std::string* DeviceBusinesscard::mutable_sigs(int index) {
  return sigs_.Mutable(index);
}
inline void DeviceBusinesscard::set_sigs(int index, const ::std::string& value) {
  sigs_.Mutable(index)->assign(value);
}
inline void DeviceBusinesscard::set_sigs(int index, const char* value) {
  sigs_.Mutable(index)->assign(value);
}
inline void DeviceBusinesscard::set_sigs(int index, const void* value, size_t size) {
  sigs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceBusinesscard::add_sigs() {
  return sigs_.Add();
}
inline void DeviceBusinesscard::add_sigs(const ::std::string& value) {
  sigs_.Add()->assign(value);
}
inline void DeviceBusinesscard::add_sigs(const char* value) {
  sigs_.Add()->assign(value);
}
inline void DeviceBusinesscard::add_sigs(const void* value, size_t size) {
  sigs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DeviceBusinesscard::sigs() const {
  return sigs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DeviceBusinesscard::mutable_sigs() {
  return &sigs_;
}

// -------------------------------------------------------------------

// LinkInfo

// required .LinkInfo.Status status = 1;
inline bool LinkInfo::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinkInfo::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinkInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinkInfo::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::LinkInfo_Status LinkInfo::status() const {
  return static_cast< ::LinkInfo_Status >(status_);
}
inline void LinkInfo::set_status(::LinkInfo_Status value) {
  assert(::LinkInfo_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// required bytes left = 2;
inline bool LinkInfo::has_left() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LinkInfo::set_has_left() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LinkInfo::clear_has_left() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LinkInfo::clear_left() {
  if (left_ != &::google::protobuf::internal::kEmptyString) {
    left_->clear();
  }
  clear_has_left();
}
inline const ::std::string& LinkInfo::left() const {
  return *left_;
}
inline void LinkInfo::set_left(const ::std::string& value) {
  set_has_left();
  if (left_ == &::google::protobuf::internal::kEmptyString) {
    left_ = new ::std::string;
  }
  left_->assign(value);
}
inline void LinkInfo::set_left(const char* value) {
  set_has_left();
  if (left_ == &::google::protobuf::internal::kEmptyString) {
    left_ = new ::std::string;
  }
  left_->assign(value);
}
inline void LinkInfo::set_left(const void* value, size_t size) {
  set_has_left();
  if (left_ == &::google::protobuf::internal::kEmptyString) {
    left_ = new ::std::string;
  }
  left_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LinkInfo::mutable_left() {
  set_has_left();
  if (left_ == &::google::protobuf::internal::kEmptyString) {
    left_ = new ::std::string;
  }
  return left_;
}
inline ::std::string* LinkInfo::release_left() {
  clear_has_left();
  if (left_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = left_;
    left_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LinkInfo::set_allocated_left(::std::string* left) {
  if (left_ != &::google::protobuf::internal::kEmptyString) {
    delete left_;
  }
  if (left) {
    set_has_left();
    left_ = left;
  } else {
    clear_has_left();
    left_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes right = 3;
inline bool LinkInfo::has_right() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LinkInfo::set_has_right() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LinkInfo::clear_has_right() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LinkInfo::clear_right() {
  if (right_ != &::google::protobuf::internal::kEmptyString) {
    right_->clear();
  }
  clear_has_right();
}
inline const ::std::string& LinkInfo::right() const {
  return *right_;
}
inline void LinkInfo::set_right(const ::std::string& value) {
  set_has_right();
  if (right_ == &::google::protobuf::internal::kEmptyString) {
    right_ = new ::std::string;
  }
  right_->assign(value);
}
inline void LinkInfo::set_right(const char* value) {
  set_has_right();
  if (right_ == &::google::protobuf::internal::kEmptyString) {
    right_ = new ::std::string;
  }
  right_->assign(value);
}
inline void LinkInfo::set_right(const void* value, size_t size) {
  set_has_right();
  if (right_ == &::google::protobuf::internal::kEmptyString) {
    right_ = new ::std::string;
  }
  right_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LinkInfo::mutable_right() {
  set_has_right();
  if (right_ == &::google::protobuf::internal::kEmptyString) {
    right_ = new ::std::string;
  }
  return right_;
}
inline ::std::string* LinkInfo::release_right() {
  clear_has_right();
  if (right_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = right_;
    right_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LinkInfo::set_allocated_right(::std::string* right) {
  if (right_ != &::google::protobuf::internal::kEmptyString) {
    delete right_;
  }
  if (right) {
    set_has_right();
    right_ = right;
  } else {
    clear_has_right();
    right_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 time = 4;
inline bool LinkInfo::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LinkInfo::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LinkInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LinkInfo::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 LinkInfo::time() const {
  return time_;
}
inline void LinkInfo::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// LinkProposal

// repeated uint32 left_sig_algos = 1;
inline int LinkProposal::left_sig_algos_size() const {
  return left_sig_algos_.size();
}
inline void LinkProposal::clear_left_sig_algos() {
  left_sig_algos_.Clear();
}
inline ::google::protobuf::uint32 LinkProposal::left_sig_algos(int index) const {
  return left_sig_algos_.Get(index);
}
inline void LinkProposal::set_left_sig_algos(int index, ::google::protobuf::uint32 value) {
  left_sig_algos_.Set(index, value);
}
inline void LinkProposal::add_left_sig_algos(::google::protobuf::uint32 value) {
  left_sig_algos_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
LinkProposal::left_sig_algos() const {
  return left_sig_algos_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
LinkProposal::mutable_left_sig_algos() {
  return &left_sig_algos_;
}

// required bytes link_info_msg = 3;
inline bool LinkProposal::has_link_info_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LinkProposal::set_has_link_info_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LinkProposal::clear_has_link_info_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LinkProposal::clear_link_info_msg() {
  if (link_info_msg_ != &::google::protobuf::internal::kEmptyString) {
    link_info_msg_->clear();
  }
  clear_has_link_info_msg();
}
inline const ::std::string& LinkProposal::link_info_msg() const {
  return *link_info_msg_;
}
inline void LinkProposal::set_link_info_msg(const ::std::string& value) {
  set_has_link_info_msg();
  if (link_info_msg_ == &::google::protobuf::internal::kEmptyString) {
    link_info_msg_ = new ::std::string;
  }
  link_info_msg_->assign(value);
}
inline void LinkProposal::set_link_info_msg(const char* value) {
  set_has_link_info_msg();
  if (link_info_msg_ == &::google::protobuf::internal::kEmptyString) {
    link_info_msg_ = new ::std::string;
  }
  link_info_msg_->assign(value);
}
inline void LinkProposal::set_link_info_msg(const void* value, size_t size) {
  set_has_link_info_msg();
  if (link_info_msg_ == &::google::protobuf::internal::kEmptyString) {
    link_info_msg_ = new ::std::string;
  }
  link_info_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LinkProposal::mutable_link_info_msg() {
  set_has_link_info_msg();
  if (link_info_msg_ == &::google::protobuf::internal::kEmptyString) {
    link_info_msg_ = new ::std::string;
  }
  return link_info_msg_;
}
inline ::std::string* LinkProposal::release_link_info_msg() {
  clear_has_link_info_msg();
  if (link_info_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = link_info_msg_;
    link_info_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LinkProposal::set_allocated_link_info_msg(::std::string* link_info_msg) {
  if (link_info_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete link_info_msg_;
  }
  if (link_info_msg) {
    set_has_link_info_msg();
    link_info_msg_ = link_info_msg;
  } else {
    clear_has_link_info_msg();
    link_info_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated bytes left_sigs = 4;
inline int LinkProposal::left_sigs_size() const {
  return left_sigs_.size();
}
inline void LinkProposal::clear_left_sigs() {
  left_sigs_.Clear();
}
inline const ::std::string& LinkProposal::left_sigs(int index) const {
  return left_sigs_.Get(index);
}
inline ::std::string* LinkProposal::mutable_left_sigs(int index) {
  return left_sigs_.Mutable(index);
}
inline void LinkProposal::set_left_sigs(int index, const ::std::string& value) {
  left_sigs_.Mutable(index)->assign(value);
}
inline void LinkProposal::set_left_sigs(int index, const char* value) {
  left_sigs_.Mutable(index)->assign(value);
}
inline void LinkProposal::set_left_sigs(int index, const void* value, size_t size) {
  left_sigs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LinkProposal::add_left_sigs() {
  return left_sigs_.Add();
}
inline void LinkProposal::add_left_sigs(const ::std::string& value) {
  left_sigs_.Add()->assign(value);
}
inline void LinkProposal::add_left_sigs(const char* value) {
  left_sigs_.Add()->assign(value);
}
inline void LinkProposal::add_left_sigs(const void* value, size_t size) {
  left_sigs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LinkProposal::left_sigs() const {
  return left_sigs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LinkProposal::mutable_left_sigs() {
  return &left_sigs_;
}

// -------------------------------------------------------------------

// LinkPromise

// repeated uint32 left_sig_algos = 1;
inline int LinkPromise::left_sig_algos_size() const {
  return left_sig_algos_.size();
}
inline void LinkPromise::clear_left_sig_algos() {
  left_sig_algos_.Clear();
}
inline ::google::protobuf::uint32 LinkPromise::left_sig_algos(int index) const {
  return left_sig_algos_.Get(index);
}
inline void LinkPromise::set_left_sig_algos(int index, ::google::protobuf::uint32 value) {
  left_sig_algos_.Set(index, value);
}
inline void LinkPromise::add_left_sig_algos(::google::protobuf::uint32 value) {
  left_sig_algos_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
LinkPromise::left_sig_algos() const {
  return left_sig_algos_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
LinkPromise::mutable_left_sig_algos() {
  return &left_sig_algos_;
}

// repeated uint32 right_sig_algos = 2;
inline int LinkPromise::right_sig_algos_size() const {
  return right_sig_algos_.size();
}
inline void LinkPromise::clear_right_sig_algos() {
  right_sig_algos_.Clear();
}
inline ::google::protobuf::uint32 LinkPromise::right_sig_algos(int index) const {
  return right_sig_algos_.Get(index);
}
inline void LinkPromise::set_right_sig_algos(int index, ::google::protobuf::uint32 value) {
  right_sig_algos_.Set(index, value);
}
inline void LinkPromise::add_right_sig_algos(::google::protobuf::uint32 value) {
  right_sig_algos_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
LinkPromise::right_sig_algos() const {
  return right_sig_algos_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
LinkPromise::mutable_right_sig_algos() {
  return &right_sig_algos_;
}

// required bytes link_info_msg = 3;
inline bool LinkPromise::has_link_info_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LinkPromise::set_has_link_info_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LinkPromise::clear_has_link_info_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LinkPromise::clear_link_info_msg() {
  if (link_info_msg_ != &::google::protobuf::internal::kEmptyString) {
    link_info_msg_->clear();
  }
  clear_has_link_info_msg();
}
inline const ::std::string& LinkPromise::link_info_msg() const {
  return *link_info_msg_;
}
inline void LinkPromise::set_link_info_msg(const ::std::string& value) {
  set_has_link_info_msg();
  if (link_info_msg_ == &::google::protobuf::internal::kEmptyString) {
    link_info_msg_ = new ::std::string;
  }
  link_info_msg_->assign(value);
}
inline void LinkPromise::set_link_info_msg(const char* value) {
  set_has_link_info_msg();
  if (link_info_msg_ == &::google::protobuf::internal::kEmptyString) {
    link_info_msg_ = new ::std::string;
  }
  link_info_msg_->assign(value);
}
inline void LinkPromise::set_link_info_msg(const void* value, size_t size) {
  set_has_link_info_msg();
  if (link_info_msg_ == &::google::protobuf::internal::kEmptyString) {
    link_info_msg_ = new ::std::string;
  }
  link_info_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LinkPromise::mutable_link_info_msg() {
  set_has_link_info_msg();
  if (link_info_msg_ == &::google::protobuf::internal::kEmptyString) {
    link_info_msg_ = new ::std::string;
  }
  return link_info_msg_;
}
inline ::std::string* LinkPromise::release_link_info_msg() {
  clear_has_link_info_msg();
  if (link_info_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = link_info_msg_;
    link_info_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LinkPromise::set_allocated_link_info_msg(::std::string* link_info_msg) {
  if (link_info_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete link_info_msg_;
  }
  if (link_info_msg) {
    set_has_link_info_msg();
    link_info_msg_ = link_info_msg;
  } else {
    clear_has_link_info_msg();
    link_info_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated bytes left_sigs = 4;
inline int LinkPromise::left_sigs_size() const {
  return left_sigs_.size();
}
inline void LinkPromise::clear_left_sigs() {
  left_sigs_.Clear();
}
inline const ::std::string& LinkPromise::left_sigs(int index) const {
  return left_sigs_.Get(index);
}
inline ::std::string* LinkPromise::mutable_left_sigs(int index) {
  return left_sigs_.Mutable(index);
}
inline void LinkPromise::set_left_sigs(int index, const ::std::string& value) {
  left_sigs_.Mutable(index)->assign(value);
}
inline void LinkPromise::set_left_sigs(int index, const char* value) {
  left_sigs_.Mutable(index)->assign(value);
}
inline void LinkPromise::set_left_sigs(int index, const void* value, size_t size) {
  left_sigs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LinkPromise::add_left_sigs() {
  return left_sigs_.Add();
}
inline void LinkPromise::add_left_sigs(const ::std::string& value) {
  left_sigs_.Add()->assign(value);
}
inline void LinkPromise::add_left_sigs(const char* value) {
  left_sigs_.Add()->assign(value);
}
inline void LinkPromise::add_left_sigs(const void* value, size_t size) {
  left_sigs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LinkPromise::left_sigs() const {
  return left_sigs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LinkPromise::mutable_left_sigs() {
  return &left_sigs_;
}

// repeated bytes right_sigs = 5;
inline int LinkPromise::right_sigs_size() const {
  return right_sigs_.size();
}
inline void LinkPromise::clear_right_sigs() {
  right_sigs_.Clear();
}
inline const ::std::string& LinkPromise::right_sigs(int index) const {
  return right_sigs_.Get(index);
}
inline ::std::string* LinkPromise::mutable_right_sigs(int index) {
  return right_sigs_.Mutable(index);
}
inline void LinkPromise::set_right_sigs(int index, const ::std::string& value) {
  right_sigs_.Mutable(index)->assign(value);
}
inline void LinkPromise::set_right_sigs(int index, const char* value) {
  right_sigs_.Mutable(index)->assign(value);
}
inline void LinkPromise::set_right_sigs(int index, const void* value, size_t size) {
  right_sigs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LinkPromise::add_right_sigs() {
  return right_sigs_.Add();
}
inline void LinkPromise::add_right_sigs(const ::std::string& value) {
  right_sigs_.Add()->assign(value);
}
inline void LinkPromise::add_right_sigs(const char* value) {
  right_sigs_.Add()->assign(value);
}
inline void LinkPromise::add_right_sigs(const void* value, size_t size) {
  right_sigs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LinkPromise::right_sigs() const {
  return right_sigs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LinkPromise::mutable_right_sigs() {
  return &right_sigs_;
}

// -------------------------------------------------------------------

// Subgraph

// repeated .DeviceBusinesscard devices = 1;
inline int Subgraph::devices_size() const {
  return devices_.size();
}
inline void Subgraph::clear_devices() {
  devices_.Clear();
}
inline const ::DeviceBusinesscard& Subgraph::devices(int index) const {
  return devices_.Get(index);
}
inline ::DeviceBusinesscard* Subgraph::mutable_devices(int index) {
  return devices_.Mutable(index);
}
inline ::DeviceBusinesscard* Subgraph::add_devices() {
  return devices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DeviceBusinesscard >&
Subgraph::devices() const {
  return devices_;
}
inline ::google::protobuf::RepeatedPtrField< ::DeviceBusinesscard >*
Subgraph::mutable_devices() {
  return &devices_;
}

// repeated .LinkPromise links = 2;
inline int Subgraph::links_size() const {
  return links_.size();
}
inline void Subgraph::clear_links() {
  links_.Clear();
}
inline const ::LinkPromise& Subgraph::links(int index) const {
  return links_.Get(index);
}
inline ::LinkPromise* Subgraph::mutable_links(int index) {
  return links_.Mutable(index);
}
inline ::LinkPromise* Subgraph::add_links() {
  return links_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::LinkPromise >&
Subgraph::links() const {
  return links_;
}
inline ::google::protobuf::RepeatedPtrField< ::LinkPromise >*
Subgraph::mutable_links() {
  return &links_;
}

// -------------------------------------------------------------------

// RoutingRequest

// required uint32 enc_algo = 1;
inline bool RoutingRequest::has_enc_algo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoutingRequest::set_has_enc_algo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoutingRequest::clear_has_enc_algo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoutingRequest::clear_enc_algo() {
  enc_algo_ = 0u;
  clear_has_enc_algo();
}
inline ::google::protobuf::uint32 RoutingRequest::enc_algo() const {
  return enc_algo_;
}
inline void RoutingRequest::set_enc_algo(::google::protobuf::uint32 value) {
  set_has_enc_algo();
  enc_algo_ = value;
}

// optional bytes sender_pubkey = 2;
inline bool RoutingRequest::has_sender_pubkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoutingRequest::set_has_sender_pubkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoutingRequest::clear_has_sender_pubkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoutingRequest::clear_sender_pubkey() {
  if (sender_pubkey_ != &::google::protobuf::internal::kEmptyString) {
    sender_pubkey_->clear();
  }
  clear_has_sender_pubkey();
}
inline const ::std::string& RoutingRequest::sender_pubkey() const {
  return *sender_pubkey_;
}
inline void RoutingRequest::set_sender_pubkey(const ::std::string& value) {
  set_has_sender_pubkey();
  if (sender_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    sender_pubkey_ = new ::std::string;
  }
  sender_pubkey_->assign(value);
}
inline void RoutingRequest::set_sender_pubkey(const char* value) {
  set_has_sender_pubkey();
  if (sender_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    sender_pubkey_ = new ::std::string;
  }
  sender_pubkey_->assign(value);
}
inline void RoutingRequest::set_sender_pubkey(const void* value, size_t size) {
  set_has_sender_pubkey();
  if (sender_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    sender_pubkey_ = new ::std::string;
  }
  sender_pubkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoutingRequest::mutable_sender_pubkey() {
  set_has_sender_pubkey();
  if (sender_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    sender_pubkey_ = new ::std::string;
  }
  return sender_pubkey_;
}
inline ::std::string* RoutingRequest::release_sender_pubkey() {
  clear_has_sender_pubkey();
  if (sender_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_pubkey_;
    sender_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoutingRequest::set_allocated_sender_pubkey(::std::string* sender_pubkey) {
  if (sender_pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_pubkey_;
  }
  if (sender_pubkey) {
    set_has_sender_pubkey();
    sender_pubkey_ = sender_pubkey;
  } else {
    clear_has_sender_pubkey();
    sender_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes details = 3;
inline bool RoutingRequest::has_details() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoutingRequest::set_has_details() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoutingRequest::clear_has_details() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoutingRequest::clear_details() {
  if (details_ != &::google::protobuf::internal::kEmptyString) {
    details_->clear();
  }
  clear_has_details();
}
inline const ::std::string& RoutingRequest::details() const {
  return *details_;
}
inline void RoutingRequest::set_details(const ::std::string& value) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void RoutingRequest::set_details(const char* value) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void RoutingRequest::set_details(const void* value, size_t size) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoutingRequest::mutable_details() {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  return details_;
}
inline ::std::string* RoutingRequest::release_details() {
  clear_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = details_;
    details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoutingRequest::set_allocated_details(::std::string* details) {
  if (details_ != &::google::protobuf::internal::kEmptyString) {
    delete details_;
  }
  if (details) {
    set_has_details();
    details_ = details;
  } else {
    clear_has_details();
    details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Hop

// required .Hop.Type type = 1;
inline bool Hop::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hop::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hop::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hop::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Hop_Type Hop::type() const {
  return static_cast< ::Hop_Type >(type_);
}
inline void Hop::set_type(::Hop_Type value) {
  assert(::Hop_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes next = 2;
inline bool Hop::has_next() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Hop::set_has_next() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Hop::clear_has_next() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Hop::clear_next() {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    next_->clear();
  }
  clear_has_next();
}
inline const ::std::string& Hop::next() const {
  return *next_;
}
inline void Hop::set_next(const ::std::string& value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void Hop::set_next(const char* value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void Hop::set_next(const void* value, size_t size) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hop::mutable_next() {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  return next_;
}
inline ::std::string* Hop::release_next() {
  clear_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_;
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Hop::set_allocated_next(::std::string* next) {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    delete next_;
  }
  if (next) {
    set_has_next();
    next_ = next;
  } else {
    clear_has_next();
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 enc_algo = 3;
inline bool Hop::has_enc_algo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Hop::set_has_enc_algo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Hop::clear_has_enc_algo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Hop::clear_enc_algo() {
  enc_algo_ = 0u;
  clear_has_enc_algo();
}
inline ::google::protobuf::uint32 Hop::enc_algo() const {
  return enc_algo_;
}
inline void Hop::set_enc_algo(::google::protobuf::uint32 value) {
  set_has_enc_algo();
  enc_algo_ = value;
}

// optional bytes sender_pubkey = 4;
inline bool Hop::has_sender_pubkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Hop::set_has_sender_pubkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Hop::clear_has_sender_pubkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Hop::clear_sender_pubkey() {
  if (sender_pubkey_ != &::google::protobuf::internal::kEmptyString) {
    sender_pubkey_->clear();
  }
  clear_has_sender_pubkey();
}
inline const ::std::string& Hop::sender_pubkey() const {
  return *sender_pubkey_;
}
inline void Hop::set_sender_pubkey(const ::std::string& value) {
  set_has_sender_pubkey();
  if (sender_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    sender_pubkey_ = new ::std::string;
  }
  sender_pubkey_->assign(value);
}
inline void Hop::set_sender_pubkey(const char* value) {
  set_has_sender_pubkey();
  if (sender_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    sender_pubkey_ = new ::std::string;
  }
  sender_pubkey_->assign(value);
}
inline void Hop::set_sender_pubkey(const void* value, size_t size) {
  set_has_sender_pubkey();
  if (sender_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    sender_pubkey_ = new ::std::string;
  }
  sender_pubkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hop::mutable_sender_pubkey() {
  set_has_sender_pubkey();
  if (sender_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    sender_pubkey_ = new ::std::string;
  }
  return sender_pubkey_;
}
inline ::std::string* Hop::release_sender_pubkey() {
  clear_has_sender_pubkey();
  if (sender_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_pubkey_;
    sender_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Hop::set_allocated_sender_pubkey(::std::string* sender_pubkey) {
  if (sender_pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_pubkey_;
  }
  if (sender_pubkey) {
    set_has_sender_pubkey();
    sender_pubkey_ = sender_pubkey;
  } else {
    clear_has_sender_pubkey();
    sender_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes details = 5;
inline bool Hop::has_details() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Hop::set_has_details() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Hop::clear_has_details() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Hop::clear_details() {
  if (details_ != &::google::protobuf::internal::kEmptyString) {
    details_->clear();
  }
  clear_has_details();
}
inline const ::std::string& Hop::details() const {
  return *details_;
}
inline void Hop::set_details(const ::std::string& value) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void Hop::set_details(const char* value) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void Hop::set_details(const void* value, size_t size) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hop::mutable_details() {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  return details_;
}
inline ::std::string* Hop::release_details() {
  clear_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = details_;
    details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Hop::set_allocated_details(::std::string* details) {
  if (details_ != &::google::protobuf::internal::kEmptyString) {
    delete details_;
  }
  if (details) {
    set_has_details();
    details_ = details;
  } else {
    clear_has_details();
    details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Hop.NonceAlgo nonce_algo = 6;
inline bool Hop::has_nonce_algo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Hop::set_has_nonce_algo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Hop::clear_has_nonce_algo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Hop::clear_nonce_algo() {
  nonce_algo_ = 2;
  clear_has_nonce_algo();
}
inline ::Hop_NonceAlgo Hop::nonce_algo() const {
  return static_cast< ::Hop_NonceAlgo >(nonce_algo_);
}
inline void Hop::set_nonce_algo(::Hop_NonceAlgo value) {
  assert(::Hop_NonceAlgo_IsValid(value));
  set_has_nonce_algo();
  nonce_algo_ = value;
}

// -------------------------------------------------------------------

// ConnectionAccept

// optional bytes sender_pubkey = 1;
inline bool ConnectionAccept::has_sender_pubkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectionAccept::set_has_sender_pubkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectionAccept::clear_has_sender_pubkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectionAccept::clear_sender_pubkey() {
  if (sender_pubkey_ != &::google::protobuf::internal::kEmptyString) {
    sender_pubkey_->clear();
  }
  clear_has_sender_pubkey();
}
inline const ::std::string& ConnectionAccept::sender_pubkey() const {
  return *sender_pubkey_;
}
inline void ConnectionAccept::set_sender_pubkey(const ::std::string& value) {
  set_has_sender_pubkey();
  if (sender_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    sender_pubkey_ = new ::std::string;
  }
  sender_pubkey_->assign(value);
}
inline void ConnectionAccept::set_sender_pubkey(const char* value) {
  set_has_sender_pubkey();
  if (sender_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    sender_pubkey_ = new ::std::string;
  }
  sender_pubkey_->assign(value);
}
inline void ConnectionAccept::set_sender_pubkey(const void* value, size_t size) {
  set_has_sender_pubkey();
  if (sender_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    sender_pubkey_ = new ::std::string;
  }
  sender_pubkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectionAccept::mutable_sender_pubkey() {
  set_has_sender_pubkey();
  if (sender_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    sender_pubkey_ = new ::std::string;
  }
  return sender_pubkey_;
}
inline ::std::string* ConnectionAccept::release_sender_pubkey() {
  clear_has_sender_pubkey();
  if (sender_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_pubkey_;
    sender_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectionAccept::set_allocated_sender_pubkey(::std::string* sender_pubkey) {
  if (sender_pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_pubkey_;
  }
  if (sender_pubkey) {
    set_has_sender_pubkey();
    sender_pubkey_ = sender_pubkey;
  } else {
    clear_has_sender_pubkey();
    sender_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .ConnectionAccept.Auth auth = 2;
inline bool ConnectionAccept::has_auth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectionAccept::set_has_auth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectionAccept::clear_has_auth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectionAccept::clear_auth() {
  auth_ = 1;
  clear_has_auth();
}
inline ::ConnectionAccept_Auth ConnectionAccept::auth() const {
  return static_cast< ::ConnectionAccept_Auth >(auth_);
}
inline void ConnectionAccept::set_auth(::ConnectionAccept_Auth value) {
  assert(::ConnectionAccept_Auth_IsValid(value));
  set_has_auth();
  auth_ = value;
}

// required bytes cookie = 3;
inline bool ConnectionAccept::has_cookie() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectionAccept::set_has_cookie() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectionAccept::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectionAccept::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& ConnectionAccept::cookie() const {
  return *cookie_;
}
inline void ConnectionAccept::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ConnectionAccept::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void ConnectionAccept::set_cookie(const void* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectionAccept::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* ConnectionAccept::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectionAccept::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_vindicat_2eproto__INCLUDED
