// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "vindicat.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

void protobuf_ShutdownFile_vindicat_2eproto() {
  delete DeviceInfo::default_instance_;
  delete DeviceBusinesscard::default_instance_;
  delete LinkInfo::default_instance_;
  delete LinkProposal::default_instance_;
  delete LinkPromise::default_instance_;
  delete Subgraph::default_instance_;
  delete RoutingRequest::default_instance_;
  delete Hop::default_instance_;
  delete ConnectionAccept::default_instance_;
}

void protobuf_AddDesc_vindicat_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  DeviceInfo::default_instance_ = new DeviceInfo();
  DeviceBusinesscard::default_instance_ = new DeviceBusinesscard();
  LinkInfo::default_instance_ = new LinkInfo();
  LinkProposal::default_instance_ = new LinkProposal();
  LinkPromise::default_instance_ = new LinkPromise();
  Subgraph::default_instance_ = new Subgraph();
  RoutingRequest::default_instance_ = new RoutingRequest();
  Hop::default_instance_ = new Hop();
  ConnectionAccept::default_instance_ = new ConnectionAccept();
  DeviceInfo::default_instance_->InitAsDefaultInstance();
  DeviceBusinesscard::default_instance_->InitAsDefaultInstance();
  LinkInfo::default_instance_->InitAsDefaultInstance();
  LinkProposal::default_instance_->InitAsDefaultInstance();
  LinkPromise::default_instance_->InitAsDefaultInstance();
  Subgraph::default_instance_->InitAsDefaultInstance();
  RoutingRequest::default_instance_->InitAsDefaultInstance();
  Hop::default_instance_->InitAsDefaultInstance();
  ConnectionAccept::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_vindicat_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_vindicat_2eproto {
  StaticDescriptorInitializer_vindicat_2eproto() {
    protobuf_AddDesc_vindicat_2eproto();
  }
} static_descriptor_initializer_vindicat_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int DeviceInfo::kSigAlgosFieldNumber;
const int DeviceInfo::kEncAlgosFieldNumber;
const int DeviceInfo::kSigKeysFieldNumber;
const int DeviceInfo::kEncKeysFieldNumber;
const int DeviceInfo::kTimeFieldNumber;
#endif  // !_MSC_VER

DeviceInfo::DeviceInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DeviceInfo::InitAsDefaultInstance() {
}

DeviceInfo::DeviceInfo(const DeviceInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DeviceInfo::SharedCtor() {
  _cached_size_ = 0;
  time_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceInfo::~DeviceInfo() {
  SharedDtor();
}

void DeviceInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DeviceInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DeviceInfo& DeviceInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vindicat_2eproto();  return *default_instance_;
}

DeviceInfo* DeviceInfo::default_instance_ = NULL;

DeviceInfo* DeviceInfo::New() const {
  return new DeviceInfo;
}

void DeviceInfo::Clear() {
  if (_has_bits_[4 / 32] & (0xffu << (4 % 32))) {
    time_ = GOOGLE_LONGLONG(0);
  }
  sig_algos_.Clear();
  enc_algos_.Clear();
  sig_keys_.Clear();
  enc_keys_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DeviceInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 sig_algos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sig_algos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_sig_algos())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_sig_algos())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_sig_algos;
        if (input->ExpectTag(16)) goto parse_enc_algos;
        break;
      }
      
      // repeated uint32 enc_algos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_enc_algos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_enc_algos())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_enc_algos())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_enc_algos;
        if (input->ExpectTag(26)) goto parse_sig_keys;
        break;
      }
      
      // repeated bytes sig_keys = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sig_keys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_sig_keys()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_sig_keys;
        if (input->ExpectTag(34)) goto parse_enc_keys;
        break;
      }
      
      // repeated bytes enc_keys = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_enc_keys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_enc_keys()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_enc_keys;
        if (input->ExpectTag(40)) goto parse_time;
        break;
      }
      
      // optional int64 time = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DeviceInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 sig_algos = 1;
  for (int i = 0; i < this->sig_algos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->sig_algos(i), output);
  }
  
  // repeated uint32 enc_algos = 2;
  for (int i = 0; i < this->enc_algos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->enc_algos(i), output);
  }
  
  // repeated bytes sig_keys = 3;
  for (int i = 0; i < this->sig_keys_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->sig_keys(i), output);
  }
  
  // repeated bytes enc_keys = 4;
  for (int i = 0; i < this->enc_keys_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->enc_keys(i), output);
  }
  
  // optional int64 time = 5;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->time(), output);
  }
  
}

int DeviceInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[4 / 32] & (0xffu << (4 % 32))) {
    // optional int64 time = 5;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time());
    }
    
  }
  // repeated uint32 sig_algos = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->sig_algos_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->sig_algos(i));
    }
    total_size += 1 * this->sig_algos_size() + data_size;
  }
  
  // repeated uint32 enc_algos = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->enc_algos_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->enc_algos(i));
    }
    total_size += 1 * this->enc_algos_size() + data_size;
  }
  
  // repeated bytes sig_keys = 3;
  total_size += 1 * this->sig_keys_size();
  for (int i = 0; i < this->sig_keys_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->sig_keys(i));
  }
  
  // repeated bytes enc_keys = 4;
  total_size += 1 * this->enc_keys_size();
  for (int i = 0; i < this->enc_keys_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->enc_keys(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeviceInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DeviceInfo*>(&from));
}

void DeviceInfo::MergeFrom(const DeviceInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  sig_algos_.MergeFrom(from.sig_algos_);
  enc_algos_.MergeFrom(from.enc_algos_);
  sig_keys_.MergeFrom(from.sig_keys_);
  enc_keys_.MergeFrom(from.enc_keys_);
  if (from._has_bits_[4 / 32] & (0xffu << (4 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
  }
}

void DeviceInfo::CopyFrom(const DeviceInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceInfo::IsInitialized() const {
  
  return true;
}

void DeviceInfo::Swap(DeviceInfo* other) {
  if (other != this) {
    sig_algos_.Swap(&other->sig_algos_);
    enc_algos_.Swap(&other->enc_algos_);
    sig_keys_.Swap(&other->sig_keys_);
    enc_keys_.Swap(&other->enc_keys_);
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DeviceInfo::GetTypeName() const {
  return "DeviceInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int DeviceBusinesscard::kDeviceInfoMsgFieldNumber;
const int DeviceBusinesscard::kSigsFieldNumber;
#endif  // !_MSC_VER

DeviceBusinesscard::DeviceBusinesscard()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DeviceBusinesscard::InitAsDefaultInstance() {
}

DeviceBusinesscard::DeviceBusinesscard(const DeviceBusinesscard& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DeviceBusinesscard::SharedCtor() {
  _cached_size_ = 0;
  device_info_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceBusinesscard::~DeviceBusinesscard() {
  SharedDtor();
}

void DeviceBusinesscard::SharedDtor() {
  if (device_info_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete device_info_msg_;
  }
  if (this != default_instance_) {
  }
}

void DeviceBusinesscard::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DeviceBusinesscard& DeviceBusinesscard::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vindicat_2eproto();  return *default_instance_;
}

DeviceBusinesscard* DeviceBusinesscard::default_instance_ = NULL;

DeviceBusinesscard* DeviceBusinesscard::New() const {
  return new DeviceBusinesscard;
}

void DeviceBusinesscard::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_device_info_msg()) {
      if (device_info_msg_ != &::google::protobuf::internal::kEmptyString) {
        device_info_msg_->clear();
      }
    }
  }
  sigs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DeviceBusinesscard::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes device_info_msg = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_device_info_msg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_sigs;
        break;
      }
      
      // repeated bytes sigs = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sigs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_sigs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_sigs;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DeviceBusinesscard::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes device_info_msg = 1;
  if (has_device_info_msg()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->device_info_msg(), output);
  }
  
  // repeated bytes sigs = 2;
  for (int i = 0; i < this->sigs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->sigs(i), output);
  }
  
}

int DeviceBusinesscard::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes device_info_msg = 1;
    if (has_device_info_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->device_info_msg());
    }
    
  }
  // repeated bytes sigs = 2;
  total_size += 1 * this->sigs_size();
  for (int i = 0; i < this->sigs_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->sigs(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeviceBusinesscard::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DeviceBusinesscard*>(&from));
}

void DeviceBusinesscard::MergeFrom(const DeviceBusinesscard& from) {
  GOOGLE_CHECK_NE(&from, this);
  sigs_.MergeFrom(from.sigs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_device_info_msg()) {
      set_device_info_msg(from.device_info_msg());
    }
  }
}

void DeviceBusinesscard::CopyFrom(const DeviceBusinesscard& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceBusinesscard::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void DeviceBusinesscard::Swap(DeviceBusinesscard* other) {
  if (other != this) {
    std::swap(device_info_msg_, other->device_info_msg_);
    sigs_.Swap(&other->sigs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DeviceBusinesscard::GetTypeName() const {
  return "DeviceBusinesscard";
}


// ===================================================================

bool LinkInfo_Status_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const LinkInfo_Status LinkInfo::DEAD;
const LinkInfo_Status LinkInfo::PUBLIC;
const LinkInfo_Status LinkInfo::Status_MIN;
const LinkInfo_Status LinkInfo::Status_MAX;
const int LinkInfo::Status_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int LinkInfo::kStatusFieldNumber;
const int LinkInfo::kLeftFieldNumber;
const int LinkInfo::kRightFieldNumber;
const int LinkInfo::kTimeFieldNumber;
#endif  // !_MSC_VER

LinkInfo::LinkInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LinkInfo::InitAsDefaultInstance() {
}

LinkInfo::LinkInfo(const LinkInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LinkInfo::SharedCtor() {
  _cached_size_ = 0;
  status_ = 1;
  left_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  right_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  time_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LinkInfo::~LinkInfo() {
  SharedDtor();
}

void LinkInfo::SharedDtor() {
  if (left_ != &::google::protobuf::internal::kEmptyString) {
    delete left_;
  }
  if (right_ != &::google::protobuf::internal::kEmptyString) {
    delete right_;
  }
  if (this != default_instance_) {
  }
}

void LinkInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LinkInfo& LinkInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vindicat_2eproto();  return *default_instance_;
}

LinkInfo* LinkInfo::default_instance_ = NULL;

LinkInfo* LinkInfo::New() const {
  return new LinkInfo;
}

void LinkInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    status_ = 1;
    if (has_left()) {
      if (left_ != &::google::protobuf::internal::kEmptyString) {
        left_->clear();
      }
    }
    if (has_right()) {
      if (right_ != &::google::protobuf::internal::kEmptyString) {
        right_->clear();
      }
    }
    time_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LinkInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .LinkInfo.Status status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::LinkInfo_Status_IsValid(value)) {
            set_status(static_cast< ::LinkInfo_Status >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_left;
        break;
      }
      
      // required bytes left = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_left:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_left()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_right;
        break;
      }
      
      // required bytes right = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_right:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_right()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_time;
        break;
      }
      
      // optional int64 time = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LinkInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .LinkInfo.Status status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->status(), output);
  }
  
  // required bytes left = 2;
  if (has_left()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->left(), output);
  }
  
  // required bytes right = 3;
  if (has_right()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->right(), output);
  }
  
  // optional int64 time = 4;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->time(), output);
  }
  
}

int LinkInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .LinkInfo.Status status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }
    
    // required bytes left = 2;
    if (has_left()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->left());
    }
    
    // required bytes right = 3;
    if (has_right()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->right());
    }
    
    // optional int64 time = 4;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LinkInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LinkInfo*>(&from));
}

void LinkInfo::MergeFrom(const LinkInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_left()) {
      set_left(from.left());
    }
    if (from.has_right()) {
      set_right(from.right());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
  }
}

void LinkInfo::CopyFrom(const LinkInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinkInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void LinkInfo::Swap(LinkInfo* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(left_, other->left_);
    std::swap(right_, other->right_);
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LinkInfo::GetTypeName() const {
  return "LinkInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int LinkProposal::kLeftSigAlgosFieldNumber;
const int LinkProposal::kLinkInfoMsgFieldNumber;
const int LinkProposal::kLeftSigsFieldNumber;
#endif  // !_MSC_VER

LinkProposal::LinkProposal()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LinkProposal::InitAsDefaultInstance() {
}

LinkProposal::LinkProposal(const LinkProposal& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LinkProposal::SharedCtor() {
  _cached_size_ = 0;
  link_info_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LinkProposal::~LinkProposal() {
  SharedDtor();
}

void LinkProposal::SharedDtor() {
  if (link_info_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete link_info_msg_;
  }
  if (this != default_instance_) {
  }
}

void LinkProposal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LinkProposal& LinkProposal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vindicat_2eproto();  return *default_instance_;
}

LinkProposal* LinkProposal::default_instance_ = NULL;

LinkProposal* LinkProposal::New() const {
  return new LinkProposal;
}

void LinkProposal::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_link_info_msg()) {
      if (link_info_msg_ != &::google::protobuf::internal::kEmptyString) {
        link_info_msg_->clear();
      }
    }
  }
  left_sig_algos_.Clear();
  left_sigs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LinkProposal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 left_sig_algos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_left_sig_algos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_left_sig_algos())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_left_sig_algos())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_left_sig_algos;
        if (input->ExpectTag(26)) goto parse_link_info_msg;
        break;
      }
      
      // required bytes link_info_msg = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_link_info_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_link_info_msg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_left_sigs;
        break;
      }
      
      // repeated bytes left_sigs = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_left_sigs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_left_sigs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_left_sigs;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LinkProposal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 left_sig_algos = 1;
  for (int i = 0; i < this->left_sig_algos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->left_sig_algos(i), output);
  }
  
  // required bytes link_info_msg = 3;
  if (has_link_info_msg()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->link_info_msg(), output);
  }
  
  // repeated bytes left_sigs = 4;
  for (int i = 0; i < this->left_sigs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->left_sigs(i), output);
  }
  
}

int LinkProposal::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required bytes link_info_msg = 3;
    if (has_link_info_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->link_info_msg());
    }
    
  }
  // repeated uint32 left_sig_algos = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->left_sig_algos_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->left_sig_algos(i));
    }
    total_size += 1 * this->left_sig_algos_size() + data_size;
  }
  
  // repeated bytes left_sigs = 4;
  total_size += 1 * this->left_sigs_size();
  for (int i = 0; i < this->left_sigs_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->left_sigs(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LinkProposal::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LinkProposal*>(&from));
}

void LinkProposal::MergeFrom(const LinkProposal& from) {
  GOOGLE_CHECK_NE(&from, this);
  left_sig_algos_.MergeFrom(from.left_sig_algos_);
  left_sigs_.MergeFrom(from.left_sigs_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_link_info_msg()) {
      set_link_info_msg(from.link_info_msg());
    }
  }
}

void LinkProposal::CopyFrom(const LinkProposal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinkProposal::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  
  return true;
}

void LinkProposal::Swap(LinkProposal* other) {
  if (other != this) {
    left_sig_algos_.Swap(&other->left_sig_algos_);
    std::swap(link_info_msg_, other->link_info_msg_);
    left_sigs_.Swap(&other->left_sigs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LinkProposal::GetTypeName() const {
  return "LinkProposal";
}


// ===================================================================

#ifndef _MSC_VER
const int LinkPromise::kLeftSigAlgosFieldNumber;
const int LinkPromise::kRightSigAlgosFieldNumber;
const int LinkPromise::kLinkInfoMsgFieldNumber;
const int LinkPromise::kLeftSigsFieldNumber;
const int LinkPromise::kRightSigsFieldNumber;
#endif  // !_MSC_VER

LinkPromise::LinkPromise()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LinkPromise::InitAsDefaultInstance() {
}

LinkPromise::LinkPromise(const LinkPromise& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LinkPromise::SharedCtor() {
  _cached_size_ = 0;
  link_info_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LinkPromise::~LinkPromise() {
  SharedDtor();
}

void LinkPromise::SharedDtor() {
  if (link_info_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete link_info_msg_;
  }
  if (this != default_instance_) {
  }
}

void LinkPromise::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LinkPromise& LinkPromise::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vindicat_2eproto();  return *default_instance_;
}

LinkPromise* LinkPromise::default_instance_ = NULL;

LinkPromise* LinkPromise::New() const {
  return new LinkPromise;
}

void LinkPromise::Clear() {
  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (has_link_info_msg()) {
      if (link_info_msg_ != &::google::protobuf::internal::kEmptyString) {
        link_info_msg_->clear();
      }
    }
  }
  left_sig_algos_.Clear();
  right_sig_algos_.Clear();
  left_sigs_.Clear();
  right_sigs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LinkPromise::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 left_sig_algos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_left_sig_algos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_left_sig_algos())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_left_sig_algos())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_left_sig_algos;
        if (input->ExpectTag(16)) goto parse_right_sig_algos;
        break;
      }
      
      // repeated uint32 right_sig_algos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_right_sig_algos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_right_sig_algos())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_right_sig_algos())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_right_sig_algos;
        if (input->ExpectTag(26)) goto parse_link_info_msg;
        break;
      }
      
      // required bytes link_info_msg = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_link_info_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_link_info_msg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_left_sigs;
        break;
      }
      
      // repeated bytes left_sigs = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_left_sigs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_left_sigs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_left_sigs;
        if (input->ExpectTag(42)) goto parse_right_sigs;
        break;
      }
      
      // repeated bytes right_sigs = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_right_sigs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_right_sigs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_right_sigs;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LinkPromise::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 left_sig_algos = 1;
  for (int i = 0; i < this->left_sig_algos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->left_sig_algos(i), output);
  }
  
  // repeated uint32 right_sig_algos = 2;
  for (int i = 0; i < this->right_sig_algos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->right_sig_algos(i), output);
  }
  
  // required bytes link_info_msg = 3;
  if (has_link_info_msg()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->link_info_msg(), output);
  }
  
  // repeated bytes left_sigs = 4;
  for (int i = 0; i < this->left_sigs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->left_sigs(i), output);
  }
  
  // repeated bytes right_sigs = 5;
  for (int i = 0; i < this->right_sigs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->right_sigs(i), output);
  }
  
}

int LinkPromise::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // required bytes link_info_msg = 3;
    if (has_link_info_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->link_info_msg());
    }
    
  }
  // repeated uint32 left_sig_algos = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->left_sig_algos_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->left_sig_algos(i));
    }
    total_size += 1 * this->left_sig_algos_size() + data_size;
  }
  
  // repeated uint32 right_sig_algos = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->right_sig_algos_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->right_sig_algos(i));
    }
    total_size += 1 * this->right_sig_algos_size() + data_size;
  }
  
  // repeated bytes left_sigs = 4;
  total_size += 1 * this->left_sigs_size();
  for (int i = 0; i < this->left_sigs_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->left_sigs(i));
  }
  
  // repeated bytes right_sigs = 5;
  total_size += 1 * this->right_sigs_size();
  for (int i = 0; i < this->right_sigs_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->right_sigs(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LinkPromise::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LinkPromise*>(&from));
}

void LinkPromise::MergeFrom(const LinkPromise& from) {
  GOOGLE_CHECK_NE(&from, this);
  left_sig_algos_.MergeFrom(from.left_sig_algos_);
  right_sig_algos_.MergeFrom(from.right_sig_algos_);
  left_sigs_.MergeFrom(from.left_sigs_);
  right_sigs_.MergeFrom(from.right_sigs_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_link_info_msg()) {
      set_link_info_msg(from.link_info_msg());
    }
  }
}

void LinkPromise::CopyFrom(const LinkPromise& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinkPromise::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;
  
  return true;
}

void LinkPromise::Swap(LinkPromise* other) {
  if (other != this) {
    left_sig_algos_.Swap(&other->left_sig_algos_);
    right_sig_algos_.Swap(&other->right_sig_algos_);
    std::swap(link_info_msg_, other->link_info_msg_);
    left_sigs_.Swap(&other->left_sigs_);
    right_sigs_.Swap(&other->right_sigs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LinkPromise::GetTypeName() const {
  return "LinkPromise";
}


// ===================================================================

#ifndef _MSC_VER
const int Subgraph::kDevicesFieldNumber;
const int Subgraph::kLinksFieldNumber;
#endif  // !_MSC_VER

Subgraph::Subgraph()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Subgraph::InitAsDefaultInstance() {
}

Subgraph::Subgraph(const Subgraph& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Subgraph::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Subgraph::~Subgraph() {
  SharedDtor();
}

void Subgraph::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Subgraph::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Subgraph& Subgraph::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vindicat_2eproto();  return *default_instance_;
}

Subgraph* Subgraph::default_instance_ = NULL;

Subgraph* Subgraph::New() const {
  return new Subgraph;
}

void Subgraph::Clear() {
  devices_.Clear();
  links_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Subgraph::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .DeviceBusinesscard devices = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_devices:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_devices()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_devices;
        if (input->ExpectTag(18)) goto parse_links;
        break;
      }
      
      // repeated .LinkPromise links = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_links:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_links()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_links;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Subgraph::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .DeviceBusinesscard devices = 1;
  for (int i = 0; i < this->devices_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->devices(i), output);
  }
  
  // repeated .LinkPromise links = 2;
  for (int i = 0; i < this->links_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->links(i), output);
  }
  
}

int Subgraph::ByteSize() const {
  int total_size = 0;
  
  // repeated .DeviceBusinesscard devices = 1;
  total_size += 1 * this->devices_size();
  for (int i = 0; i < this->devices_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->devices(i));
  }
  
  // repeated .LinkPromise links = 2;
  total_size += 1 * this->links_size();
  for (int i = 0; i < this->links_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->links(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Subgraph::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Subgraph*>(&from));
}

void Subgraph::MergeFrom(const Subgraph& from) {
  GOOGLE_CHECK_NE(&from, this);
  devices_.MergeFrom(from.devices_);
  links_.MergeFrom(from.links_);
}

void Subgraph::CopyFrom(const Subgraph& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Subgraph::IsInitialized() const {
  
  for (int i = 0; i < devices_size(); i++) {
    if (!this->devices(i).IsInitialized()) return false;
  }
  for (int i = 0; i < links_size(); i++) {
    if (!this->links(i).IsInitialized()) return false;
  }
  return true;
}

void Subgraph::Swap(Subgraph* other) {
  if (other != this) {
    devices_.Swap(&other->devices_);
    links_.Swap(&other->links_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Subgraph::GetTypeName() const {
  return "Subgraph";
}


// ===================================================================

#ifndef _MSC_VER
const int RoutingRequest::kEncAlgoFieldNumber;
const int RoutingRequest::kSenderPubkeyFieldNumber;
const int RoutingRequest::kDetailsFieldNumber;
#endif  // !_MSC_VER

RoutingRequest::RoutingRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RoutingRequest::InitAsDefaultInstance() {
}

RoutingRequest::RoutingRequest(const RoutingRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RoutingRequest::SharedCtor() {
  _cached_size_ = 0;
  enc_algo_ = 0u;
  sender_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RoutingRequest::~RoutingRequest() {
  SharedDtor();
}

void RoutingRequest::SharedDtor() {
  if (sender_pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_pubkey_;
  }
  if (details_ != &::google::protobuf::internal::kEmptyString) {
    delete details_;
  }
  if (this != default_instance_) {
  }
}

void RoutingRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RoutingRequest& RoutingRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vindicat_2eproto();  return *default_instance_;
}

RoutingRequest* RoutingRequest::default_instance_ = NULL;

RoutingRequest* RoutingRequest::New() const {
  return new RoutingRequest;
}

void RoutingRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    enc_algo_ = 0u;
    if (has_sender_pubkey()) {
      if (sender_pubkey_ != &::google::protobuf::internal::kEmptyString) {
        sender_pubkey_->clear();
      }
    }
    if (has_details()) {
      if (details_ != &::google::protobuf::internal::kEmptyString) {
        details_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RoutingRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 enc_algo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &enc_algo_)));
          set_has_enc_algo();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_sender_pubkey;
        break;
      }
      
      // optional bytes sender_pubkey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sender_pubkey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_sender_pubkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_details;
        break;
      }
      
      // required bytes details = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_details:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_details()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RoutingRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 enc_algo = 1;
  if (has_enc_algo()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->enc_algo(), output);
  }
  
  // optional bytes sender_pubkey = 2;
  if (has_sender_pubkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->sender_pubkey(), output);
  }
  
  // required bytes details = 3;
  if (has_details()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->details(), output);
  }
  
}

int RoutingRequest::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 enc_algo = 1;
    if (has_enc_algo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->enc_algo());
    }
    
    // optional bytes sender_pubkey = 2;
    if (has_sender_pubkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->sender_pubkey());
    }
    
    // required bytes details = 3;
    if (has_details()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->details());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoutingRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RoutingRequest*>(&from));
}

void RoutingRequest::MergeFrom(const RoutingRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_enc_algo()) {
      set_enc_algo(from.enc_algo());
    }
    if (from.has_sender_pubkey()) {
      set_sender_pubkey(from.sender_pubkey());
    }
    if (from.has_details()) {
      set_details(from.details());
    }
  }
}

void RoutingRequest::CopyFrom(const RoutingRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoutingRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;
  
  return true;
}

void RoutingRequest::Swap(RoutingRequest* other) {
  if (other != this) {
    std::swap(enc_algo_, other->enc_algo_);
    std::swap(sender_pubkey_, other->sender_pubkey_);
    std::swap(details_, other->details_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RoutingRequest::GetTypeName() const {
  return "RoutingRequest";
}


// ===================================================================

bool Hop_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Hop_Type Hop::UP;
const Hop_Type Hop::SIMPLE_ONEWAY;
const Hop_Type Hop::SIMPLE_TWOWAY;
const Hop_Type Hop::Type_MIN;
const Hop_Type Hop::Type_MAX;
const int Hop::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Hop::kTypeFieldNumber;
const int Hop::kNextFieldNumber;
const int Hop::kEncAlgoFieldNumber;
const int Hop::kSenderPubkeyFieldNumber;
const int Hop::kDetailsFieldNumber;
#endif  // !_MSC_VER

Hop::Hop()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Hop::InitAsDefaultInstance() {
}

Hop::Hop(const Hop& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Hop::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  enc_algo_ = 0u;
  sender_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Hop::~Hop() {
  SharedDtor();
}

void Hop::SharedDtor() {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    delete next_;
  }
  if (sender_pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_pubkey_;
  }
  if (details_ != &::google::protobuf::internal::kEmptyString) {
    delete details_;
  }
  if (this != default_instance_) {
  }
}

void Hop::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Hop& Hop::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vindicat_2eproto();  return *default_instance_;
}

Hop* Hop::default_instance_ = NULL;

Hop* Hop::New() const {
  return new Hop;
}

void Hop::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_next()) {
      if (next_ != &::google::protobuf::internal::kEmptyString) {
        next_->clear();
      }
    }
    enc_algo_ = 0u;
    if (has_sender_pubkey()) {
      if (sender_pubkey_ != &::google::protobuf::internal::kEmptyString) {
        sender_pubkey_->clear();
      }
    }
    if (has_details()) {
      if (details_ != &::google::protobuf::internal::kEmptyString) {
        details_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Hop::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Hop.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Hop_Type_IsValid(value)) {
            set_type(static_cast< ::Hop_Type >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_next;
        break;
      }
      
      // optional bytes next = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_next:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_next()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_enc_algo;
        break;
      }
      
      // optional uint32 enc_algo = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_enc_algo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &enc_algo_)));
          set_has_enc_algo();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_sender_pubkey;
        break;
      }
      
      // optional bytes sender_pubkey = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sender_pubkey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_sender_pubkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_details;
        break;
      }
      
      // optional bytes details = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_details:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_details()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Hop::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Hop.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // optional bytes next = 2;
  if (has_next()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->next(), output);
  }
  
  // optional uint32 enc_algo = 3;
  if (has_enc_algo()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->enc_algo(), output);
  }
  
  // optional bytes sender_pubkey = 4;
  if (has_sender_pubkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->sender_pubkey(), output);
  }
  
  // optional bytes details = 5;
  if (has_details()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->details(), output);
  }
  
}

int Hop::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Hop.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // optional bytes next = 2;
    if (has_next()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->next());
    }
    
    // optional uint32 enc_algo = 3;
    if (has_enc_algo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->enc_algo());
    }
    
    // optional bytes sender_pubkey = 4;
    if (has_sender_pubkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->sender_pubkey());
    }
    
    // optional bytes details = 5;
    if (has_details()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->details());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Hop::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Hop*>(&from));
}

void Hop::MergeFrom(const Hop& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_next()) {
      set_next(from.next());
    }
    if (from.has_enc_algo()) {
      set_enc_algo(from.enc_algo());
    }
    if (from.has_sender_pubkey()) {
      set_sender_pubkey(from.sender_pubkey());
    }
    if (from.has_details()) {
      set_details(from.details());
    }
  }
}

void Hop::CopyFrom(const Hop& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Hop::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void Hop::Swap(Hop* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(next_, other->next_);
    std::swap(enc_algo_, other->enc_algo_);
    std::swap(sender_pubkey_, other->sender_pubkey_);
    std::swap(details_, other->details_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Hop::GetTypeName() const {
  return "Hop";
}


// ===================================================================

bool ConnectionAccept_Auth_IsValid(int value) {
  switch(value) {
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ConnectionAccept_Auth ConnectionAccept::AUTHENC_BCARD;
const ConnectionAccept_Auth ConnectionAccept::Auth_MIN;
const ConnectionAccept_Auth ConnectionAccept::Auth_MAX;
const int ConnectionAccept::Auth_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ConnectionAccept::kAuthFieldNumber;
const int ConnectionAccept::kCookieFieldNumber;
#endif  // !_MSC_VER

ConnectionAccept::ConnectionAccept()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ConnectionAccept::InitAsDefaultInstance() {
}

ConnectionAccept::ConnectionAccept(const ConnectionAccept& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ConnectionAccept::SharedCtor() {
  _cached_size_ = 0;
  auth_ = 1;
  cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConnectionAccept::~ConnectionAccept() {
  SharedDtor();
}

void ConnectionAccept::SharedDtor() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (this != default_instance_) {
  }
}

void ConnectionAccept::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConnectionAccept& ConnectionAccept::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_vindicat_2eproto();  return *default_instance_;
}

ConnectionAccept* ConnectionAccept::default_instance_ = NULL;

ConnectionAccept* ConnectionAccept::New() const {
  return new ConnectionAccept;
}

void ConnectionAccept::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    auth_ = 1;
    if (has_cookie()) {
      if (cookie_ != &::google::protobuf::internal::kEmptyString) {
        cookie_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ConnectionAccept::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ConnectionAccept.Auth auth = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ConnectionAccept_Auth_IsValid(value)) {
            set_auth(static_cast< ::ConnectionAccept_Auth >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_cookie;
        break;
      }
      
      // required bytes cookie = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cookie:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_cookie()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ConnectionAccept::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ConnectionAccept.Auth auth = 1;
  if (has_auth()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->auth(), output);
  }
  
  // required bytes cookie = 2;
  if (has_cookie()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->cookie(), output);
  }
  
}

int ConnectionAccept::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ConnectionAccept.Auth auth = 1;
    if (has_auth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->auth());
    }
    
    // required bytes cookie = 2;
    if (has_cookie()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->cookie());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConnectionAccept::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConnectionAccept*>(&from));
}

void ConnectionAccept::MergeFrom(const ConnectionAccept& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_auth()) {
      set_auth(from.auth());
    }
    if (from.has_cookie()) {
      set_cookie(from.cookie());
    }
  }
}

void ConnectionAccept::CopyFrom(const ConnectionAccept& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionAccept::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void ConnectionAccept::Swap(ConnectionAccept* other) {
  if (other != this) {
    std::swap(auth_, other->auth_);
    std::swap(cookie_, other->cookie_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ConnectionAccept::GetTypeName() const {
  return "ConnectionAccept";
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
